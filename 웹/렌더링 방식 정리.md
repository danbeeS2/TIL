# 웹 페이지 렌더링 방식

웹 프론트엔드에서 페이지를 렌더링하는 방식은 크게 다음 네 가지로 구분된다:

- **CSR** (Client Side Rendering)
- **SSR** (Server Side Rendering)
- **SSG** (Static Site Generation)
- **ISR** (Incremental Static Regeneration)


<br/>

## 1. `CSR`(Client Side Rendering)

> **브라우저(클라이언트)에서 자바스크립트를 통해 페이지를 렌더링**하는 방식

- 초기 HTML은 거의 비어 있고, 자바스크립트 번들 파일을 로드한 후 화면이 동적으로 구성됨
- 대표적인 프레임워크: `React`, `Vue`, `SPA (싱글 페이지 애플리케이션)`


### 1) `CSR` 장점

#### 1. 사용자 인터랙션이 빠름 (앱처럼 동작)

- 초기 한 번만 HTML을 로드하고, 이후에는 전체 페이지를 다시 불러올 필요 없음
- 내부적으로 `history.pushState()` 를 사용해 **페이지 전환 시 전체 새로고침 없이 처리**
  - Gmail, 네이버 메일 등 SPA 구조 → 클릭 시 새로고침 없이 화면 일부만 갱신
- 사용자는 앱처럼 빠르고 자연스러운 UX를 경험할 수 있음

#### 2. 서버 부하 적음

- 서버는 정적인 `HTML`, `JS`, `CSS` 파일만 클라이언트에게 전달하면 됨
- 모든 렌더링은 클라이언트에서 수행되므로 **서버의 연산 부담이 거의 없음**
- **한 번 빌드된 파일은 여러 사용자에게 캐시로 제공** 가능
  - CDN + 캐싱을 통해 수천 명이 동시에 접근해도 서버 부담이 적음

#### 3. CDN으로 정적 파일 서빙 가능

- CSR의 번들 파일은 정적 파일(`main.js`, `vendor.js`, `style.css` 등)이므로
  - 전 세계 어디서 접속하든 **가까운 CDN 엣지 서버**에서 빠르게 전달 가능
  - 사용자 위치와 무관하게 빠른 로딩이 가능함


<br/>
<br/>
<br/>

### 2) `CSR` 단점

#### 1. 초기 로딩이 느릴 수 있음

- 초기 `HTML` 이 `<div id=”root”></div>` 처럼 비어있음
- JS 번들 파일을 다운받고, JS 파싱 + 실행된 후에야 콘텐츠가 나타남 (JS가 다 로드될 때까지 기다려야 함)
- 저사양 기기나 느린 네트워크에선 **하얀 화면(blank screen)**이 길어짐

#### 2. SEO에 불리함

- 콘텐츠가 JS 실행 후 생성되므로, 크롤러가 제대로 수집하지 못할 수 있음
- 특히 네이버/다음은 JS 실행을 거의 하지 않음 → 콘텐츠 인식 불가
- **검색 유입이 중요한 페이지는 부적절**
  - 이커머스(쇼핑몰)
  - 블로그, 뉴스, 콘텐츠 플랫폼
  - 기업 웹사이트, 포트폴리오


<br/>
<br/>
<br/>

## 2. `SSR`(Server Side Rendering)

> **서버에서 HTML을 완성한 후 브라우저에 전달하는 방식**

- 사용자가 URL에 접근하면 서버가 해당 페이지의 HTML을 구성해 응답
- 대표적인 프레임워크: `Next.js`, `Nuxt.js`

---

### 1) `SSR` 장점

#### 1. 초기 페이지 로딩 빠름

- 서버에서 완성된 HTML을 보내기 때문에 **브라우저는 곧바로 렌더링 가능**
- JS가 실행되기 전에도 콘텐츠가 보이므로 체감 속도가 빠름
  - 특히 **로그인 전 랜딩 페이지, 상품 상세, 메인 페이지**는 SSR로 빠르게 보여줘야 함
- 모바일/저사양 환경에서도 유리함

#### 2. SEO에 유리함 (검색엔진 최적화)

- HTML에 콘텐츠가 포함되어 있어 검색 엔진이 쉽게 크롤링 가능
- 메타태그, OG 태그 등도 포함 가능
- 블로그, 쇼핑몰, 콘텐츠 서비스 등에 적합

---

### 2) `SSR` 단점

#### 1. 서버 부하 증가

- 모든 요청마다 서버가 **HTML을 새로 생성**해야 하기 때문에, 서버 연산량 많음
- 동시 접속자가 많을수록 서버에 부하가 커짐
  - 100명이 동일한 페이지를 요청할 경우 → 100번 렌더링

#### 2. 페이지 전환 시 느릴 수 있음

- CSR은 클라이언트에서 상태를 유지하지만,
  SSR은 **페이지 이동 시마다 새 요청**이 발생해 콘텐츠를 다시 받아야 함
- 내부 전환이 많은 서비스에서는 체감상 느려질 수 있음

<br/>
<br/>
<br/>

## 3. `SSG` (Static Site Generation, 정적 사이트 생성)

> 빌드 시점에 HTML을 미리 생성해 저장하는 방식

### 1) `SSG` 장점

- 사용자가 요청하면 서버는 이미 만들어진 HTML을 그냥 보내줌 (**서버 부하 없음)**
- 캐싱, CDN 적용이 쉬움

### 2) `SSG` 단점

- 콘텐츠 변경 시 다시 빌드 필요
- 실시간 데이터 반영 어려움
  - 주로 자주 바뀌지 않은 콘텐츠에 사용함 (블로그 글, 소개 페이지, 공지사항 등)

```jsx
// Next.js 예시 - getStaticProps
export async function getStaticProps() {
  const data = await fetch("https://api.example.com/posts");
  return { props: { data } };
}
```


<br/>
<br/>
<br/>

## 4. `ISR` (Incremental Static Regeneration, 점진적 정적 재생성)

> 일정 시간마다 정적 페이지 재생성 (SSG + 유연성)

### 1) `ISR` 장점

- HTML을 미리 만들어두되, 일정 시간이 지나면 다시 생성할 수 있게 함
- 변경사항이 반영되면서도 성능과 캐시의 장점을 동시에 누릴 수 있음
- 주기적으로 갱신되지만 실시간성은 필요 없는 콘텐츠 (상품 목록, 인기글 등) 에 적합

### 2) `ISR` 단점

- 실시간성은 SSR보다 떨어짐

```jsx
// Next.js 예시 -  getStaticProps + revalidate
export async function getStaticProps() {
  const data = await fetch("https://api.example.com/products");
  return {
    props: { data },
    revalidate: 60, // 60초마다 재생성
  };
}
```

- 사용자가 페이지를 요청하면, 정적 페이지가 먼저 응답됨
- 이후 revalidate 시간이 지나면 다음 요청 시 백그라운드에서 정적 HTML을 다시 생성



<br/>
<br/>
<br/>

## 5. 하이브리드 방식

과거에는 SSR과 CSR 중 하나를 선택해야 했지만,
**Next.js, Nuxt.js 같은 프레임워크는 페이지 단위로 `SSR` / `CSR` / `SSG` / `ISR`을 혼합해서 사용 가능함**

⇒ 로그인 여부, 페이지 목적에 따라 **전략적으로 선택**

| 상황                           | 렌더링 방식                             | 이유                                          |
| ------------------------------ | --------------------------------------- | --------------------------------------------- |
| **로그인 안 한 사용자의 홈**   | `SSR` (`getServerSideProps`)            | 첫 진입 속도 + SEO가 중요 (공개 콘텐츠)       |
| **로그인한 사용자의 대시보드** | `CSR` (`use client` + `useEffect`)      | 개인 데이터 기반으로 서버에서 미리 렌더 불가  |
| **상품 상세 페이지**           | `ISR` (`getStaticProps` + `revalidate`) | SEO + 갱신 필요, 하지만 실시간성은 낮음       |
| **공지사항 / 소개 페이지**     | `SSG` (`getStaticProps`)                | 거의 바뀌지 않는 정적 페이지, 퍼포먼스 극대화 |



## 6. 요약

| 방식         | 적용 방식                            | 실행 시점                     | 특징                       | SEO | 퍼포먼스           | 용도              |
| ------------ | ------------------------------------ | ----------------------------- | -------------------------- | --- | ------------------ | ----------------- |
| **CSR**      | `useEffect`로 클라이언트 fetch, `use client` | 클라이언트 실행 시점                 | 인터랙션 빠름, 서버 부하 없음 | X                          | ◯   | 대시보드, 장바구니 |
| **SSR**      | `getServerSideProps`                 | 요청 시 (runtime)             | 항상 최신 데이터, SEO 가능 | ◎   | △                  | 홈, 랜딩          |
| **SSG**      | `getStaticProps`                     | 빌드 시                       | 정적 페이지, CDN 가능      | ◎   | ◎                  | 소개, 블로그      |
| **ISR**      | `getStaticProps` + `revalidate` 옵션 | 빌드 + 일정 간격 재생성       | SSG + 유연성               | ◎   | ◎                  | 상품 목록, 인기글 |

### 실전 페이지별 전략

| 페이지           | 렌더링 방식 | 이유                                             |
| ---------------- | ----------- | ------------------------------------------------ |
| `/` (홈)         | SSR         | 최신 인기 콘텐츠를 SEO에 반영                    |
| `/about`         | SSG         | 거의 변하지 않는 정적 페이지                     |
| `/products/[id]` | ISR         | 상품 정보는 자주는 안 바뀌지만 변경 가능성 있음  |
| `/cart`          | CSR         | 로그인한 사용자마다 다름 → 클라이언트에서만 가능 |
