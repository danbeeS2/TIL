# 1. 연결 리스트 (Linked List)

![연결 리스트](/자료구조//images/linkedlist.png)

## 1) 배열 vs 연결 리스트

### 배열 (Array)
- 모든 언어에서 제공하는 선형 자료구조
- 메모리에 **연속된 공간**에 저장됨
- 인덱스로 즉시 접근 가능 → `O(1)`
- **단점**: 삽입/삭제 시 전체를 옮겨야 할 수 있음 → `O(n)`

### 연결 리스트 (Linked List)
- 메모리에 **흩어진 공간**에 존재
- 각 노드가 다음 노드의 **주소(참조)** 를 가지고 있음
- **데이터 추가/삭제는 유연**하지만, **접근은 느림** → `O(n)`


## 2) 연결 리스트 구조 (메모리 관점)

ex. `[1, 2, 3, 4, 5, 6]`

```text
[배열]
메모리: A1 A2 A3 A4 A5 A6
값:     1  2  3  4  5  6

[연결 리스트]
A1: 값 1 → 다음 B1
B1: 값 2 → 다음 C1
C1: 값 3 → 다음 D1
D1: 값 4 → 다음 E1
E1: 값 5 → 다음 F1
F1: 값 6 → 다음 null
```
- `배열`은 연속된 메모리 → A1 ~ A6
- `연결 리스트`는 객체들이 서로 **주소**로 이어짐 → 포인터 기반

## 3) 연결 리스트의 시간 복잡도

| 연산    | 설명       | 시간 복잡도 |
| ----- | -------- | ------ |
| 조회    | 특정 값 찾기  | `O(n)`   |
| 삽입    | 마지막에 추가  | `O(n)`  |
| 수정    | 특정 위치 수정 | `O(n)`  |
| 삭제    | 특정 위치 제거 | `O(n)`  |
| 앞에 삽입 | head 조작  | `O(1)`   |

조회 / 삽입 / 수정 / 삭제 모두   
`A1 → B1 → C1 → D1 → E1 → F1` 매번 한 칸씩 따라가야 함 ⇒ `O(n)`


## 4) 연결 리스트의 단점
- **임의 접근 불가능** → 인덱스로 바로 못 감
- **다음 노드만 알고 있음** (단일 연결 리스트)
    - 이중 연결 리스트 사용 시 해결됨
- **데이터 위치 찾는 데 시간이 오래 걸림**

## 5) 연결 리스트를 쓰는 이유
- **삽입/삭제가 빈번할 때 효율적**
    - 위치를 알고 있다면, 포인터(주소)만 바꾸면 됨 ⇒ `O(1)` **( 요소 이동 없음 )**
- 메모리가 연속되지 않아도 동작 가능
- 트리, 그래프, 큐 등 다양한 자료구조의 기반이 됨

## 6) 종류
| 종류                                   | 설명                                  |
| ------------------------------------ | ----------------------------------- |
| **단일 연결 리스트** (Singly Linked List)   | 노드가 한 방향으로만 연결됨 (`next`만 있음)        |
| **이중 연결 리스트** (Doubly Linked List)   | 노드가 앞뒤로 연결됨 (`prev`, `next` 둘 다 있음) |
| **원형 연결 리스트** (Circular Linked List) | 마지막 노드가 처음 노드를 가리킴 (순환 구조)          |
