# 1. 트리와 이진 트리 종류

![트리와 이진틀리 종류](/자료구조/images/treeandbinarytree.png)

## 1) 트리

- `root` : 트리의 시작점
- `node` : 가지로 연결
- `leaf` : 자식이 없는 가장 마지막 부분의 node

<br/>

## 2) 이진 트리

- 자식의 개수가 최대 2개인 트리
  - 자식이 2개, 1개, 0개 일 수 있음

### 이진 트리 종류

> - **관련 용어 정리**
>   - `level` : 노드의 깊이, 층
>   - `height`: 가지의 길이
>   - `diff`: 자기 기준으로 왼쪽 최대 `height`와 오른쪽 최대 `height`의 차이

#### 1. `Full` binary tree

- **모든 자식이 0개 또는 2개**인 트리
- `Balanced` 트리가 아닐 수 있음

#### 2. `Perfect` binary tree

- `leaf`가 아닌 노드: 자식이 모두 2개여야 함
- `leaf`인 노드: 모두 같은 `level`이어야 함
- **다 꽉차 있는 삼각형 모양**
- `Balanced` 트리에 포함됨

#### 3. `Complete` binary tree

- **왼쪽부터** 데이터를 순서대로 채워나가야 함
- 데이터를 하나씩 순서대로 넣을 때 사용
- `Balanced` 트리에 포함됨

#### 4. `Degenerate` binary tree

- 자식의 개수가 모두 1개인 트리
  - **Linked List**와 같은 형태
- 가장 비효율적인 이진 트리 - 시간 복잡도 `O(n)`

#### 5. `Balanced` binary tree

- 모든 노드의 `diff`가 0개 / 1개 인 트리

<br/>
# 2. ⭐️ 이진 탐색 트리 ⭐️

: 어떤 노드를 기준으로 그 노드보다 `작은 값`들은 `왼쪽`, 그 노드보다 `큰 값`들은 `오른쪽`에 미리 배치되어 있는 트리

- `탐색` ⇒ `정렬되어 있다`는 의미
  - 큰 값, 작은 값이 정렬되어 있기 때문에 조회/삽입/삭제 모두 `O(log n)`
  - **엄청 효율적인 자료구조** (1 < `log n` < n)
  - 다만, 시간 복잡도가 `O(log n)`을 만족하기 위해서는 `Balanced`이어야 한다는 조건이 있음 (이를 위해서는 AVL트리, 레드블랙 트리 작업이 필요함)

![이진탐색트리](/자료구조/images/binarysearchtree.png)

---

![이진탐색트리 삽입](/자료구조/images/binarysearchtree_img.png)

> 5, 9, 4, 14, 19, 23, 7, 11, 8, 2, 16

<br/>

### 1. 삽입에 대한 정리. `insert()`

1. 어떤 값을 넣으려고할 때, 일단 어디에 넣을지 모르겠다.
2. 그래서 왼쪽, 오른쪽에게 위임한다. ( 맡긴다, 처리하라고 한다. )
3. 근데 만약, 왼쪽 또는 오른쪽이 없다면 그 자리에 삽입한다.

> 5입장에서 11을 넣으려고 할 때, 9와 14에게 위임한 뒤, 11을 추가할 수 있다.<br/>
> 14에게 위임할 때, 왼쪽을 찾으려고 했더니 왼쪽이 없는 상황이다.<br/>
> 11을 넣고자 하는 상황에 왼쪽이 비어있다는 것을 인지한다.

1. 상위 값보다 넣으려는 값이 큰지, 작은지를 인지(조건문)하고 값을 넣는다.<br/>
   **깔끔하고 명확하게 넣어줘야하기 때문에** 추가적으로, 그 자리에 값이 있는지 없는지를 판단하는 조건을 추가한다.
2. 있다면 다시 재귀함수를 호출한다.
3. 없다면( 비어있다면 ), 그 자리에 값을 삽입한다.<br/>
   (이것이 **재귀함수를 사용하는 것** 이다.)

```javascript
#insert(node, value) {
  if (node.value > value) {
    // 상위 값보다 넣으려고 하는 값이 작으면, 왼쪽
    if (node.left) {
      // 왼쪽에 값이 있으면, 왼쪽에 있는 값에게 처리를 넘김
      this.#insert(node.left, value);
    } else {
      // 만약 왼쪽이 비어있다면? 왼쪽에 추가
      node.left = new Node(value);
    }
  } else {
    // 상위 값보다 넣으려고 하는 값이 크면, 오른쪽
    if (node.right) {
      // 오른쪽에 값이 있으면, 오른쪽에 있는 값에게 처리를 넘김
      this.#insert(node.right, value);
    } else {
      // 만약 오른쪽이 비어있다면? 오른쪽에 추가
      node.right = new Node(value);
    }
  }
}
```

<br/>

### 2. 검색(조회)에 대한 정리 `search()`

- 해당 값을 검사하고 찾아 처리해줘야하기 때문에, 모든 값을 `return` 해줘야한다.
- 수정은 검색(조회)를 활용한다.
- `#insert()`재귀함수와 동일한 조건의 틀을 가진다.
  - 찾는 값과 해당 node가 같은지(조건)와 결과를 `return`을 해줘야하는 부분만 다르다.

1. 11을 찾는다고 가정하고 코드의 흐름을 따라간다.
2. 또, 없는 값을 생각하고 어떻게 코드가 흐르는지도 파악한다. ( 어떻게 해서 `null`을 `return` 하는지 )
