# 자바스크립트의 동등 비교

- 리액트는 `props`, `state` 가 바뀌었는지 비교해 **컴포넌트를 다시 렌더링할지 말지**를 결정한다.
- 이때 쓰이는 비교 방식이 **얕은(shallow) 동등 비교** 이다.

  - 원시 타입: 값 자체를 비교
  - 참조 타입: **참조(주소)** 만 비교

그 외에도 리액트의 가상 DOM과 실제 DOM의 비교, 리액트 컴포넌트가 렌더링할지를 판단하는 방법, 변수나 함수의 메모이제이션 등 모든 작업은 자바스크립트의 동등 비교를 기반으로 한다.

## 1) 자바스크립트 데이터 타입

### 1. 원시 타입 (Primitive Type)

- **값 자체가 저장**되고, **불변(immutable)**.
- 종류: `number`, `string`, `boolean`, `null`, `undefined`, `symbol`, `bigint`

  ```js
  let a = 10;
  let b = a; // 값 복사
  b = 20;

  console.log(a); // 10 (a와 b는 독립적)
  ```

- 값을 바꾸면 **새로운 메모리 공간**을 만들어 다른 식별자와 연결한다.

---

### 2. 참조 타입 (Reference Type)

- 객체, 배열, 함수 등 **객체형 데이터**.
- 변수에는 **값이 아니라 주소(참조)** 가 저장됨.
- 따라서 **복사하면 참조(주소)만 공유** → 내부 값 변경 시 다른 변수에서도 영향.

  ```js
  let obj1 = { value: 1 };
  let obj2 = obj1; // 주소 복사
  obj2.value = 2;

  console.log(obj1.value); // 2 (같은 객체를 가리킴)
  ```

  <br />

## 2) 값 저장 방식의 차이

| 구분      | 저장 방식       | 특징                                   |
| --------- | --------------- | -------------------------------------- |
| 원시 타입 | 값 자체 저장    | 값 변경 시 새 공간 할당 (불변)         |
| 참조 타입 | 참조(주소) 저장 | 같은 객체를 여러 변수가 공유할 수 있음 |

### 1. 원시 타입 (Primitive)

```js
let a = 10;
let b = a;
b = 20;
```

```js
메모리 구조
  a ──▶ (주소:0x100) ──▶ (주소:0x1000) ──▶ 10
  b ──▶ (주소:0x200) ──▶ (주소:0x1000) ──▶ 10  // b = a 할 때 같은 값 주소를 참조
```

- `b = a` 할 때 **a가 참조하던 값(10)의 주소(0x1000)를 복사**해옴.

```js
메모리 구조
  a ──▶ (주소:0x100) ──▶ (주소:0x1000) ──▶ 10
  b ──▶ (주소:0x200) ──▶ (주소:0x1001) ──▶ 20
```

- `b = 20`하면 값 `20`이 는 새로운 데이터 영역(0x1001)에 저장되고,  
  `b`가 가리키는 참조가 0x1001로 바뀜.
- `a`는 여전히 0x1000을 바라보고 있으므로 영향 없음.
- 주소가 다르니까 독립적.

➡️ 원시 타입은 값이 변하면 무조건 **새로운 주소**가 할당됨 (불변성)

---

### 2. 참조 타입 (Reference)

```js
const obj1 = { x: 1 };
const obj2 = obj1;
obj2.x = 2;
```

```js
메모리 구조
  obj1 ──▶ (주소:0x300) ──▶ (주소:0x400) ──▶ { x ──▶ (주소:0x1000) ──▶ 1 }
  obj2 ──▶ (주소:0x500) ──┘
```

- `obj1`과 `obj2`는 같은 객체 주소(0x400)를 공유.

이후 `obj2.x = 2` 실행 시

```js
메모리 구조
  obj1 ──▶ (주소:0x300) ──▶ (주소:0x400) ──▶ { x ──▶ (주소:0x1001) ──▶ 2 }
  obj2 ──▶ (주소:0x500) ──┘
```

- 객체 내부의 프로퍼티 `x`는 원시 값이므로 새로운 값(`2`)이 들어올 때
  데이터 영역 새 주소(0x1001)에 저장됨.
- 이제 `x`는 0x1001을 가리키므로 `obj1.x`와 `obj2.x`가 모두 `2`로 바뀌어 보이는 것.

---

### 3. 참조 타입의 주의사항

동일하게 선언했던 객체라도 저장하는 순간 **서로 다른 참조(주소)** 를 바라보게 되므로 동등 비교(`===`) 시 `false`를 반환함. 즉, 값이 같더라도 참조하는 곳이 다르면 **다른 객체**로 인식된다.

하지만 **참조 자체를 전달**하는 경우에는 같은 주소를 공유하기 때문에,
원시 값처럼 같은 결과를 확인할 수 있다.

```js
// 1) 동일한 리터럴 객체를 각각 생성
const obj1 = { x: 1 }; // obj1 → (주소:0x100) → (주소:0x1000) → { x: 1 }
const obj2 = { x: 1 }; // obj2 → (주소:0x200) → (주소:0x2000) → { x: 1 }

console.log(obj1 === obj2); //  모양은 같지만 서로 다른 주소를 바라봄 → false

// 2) 같은 참조를 공유
const obj3 = obj1; // obj1 → (주소:0x100) → (주소:0x1000) → { x: 1 }
// obj3 → (주소:0x300) ──┘

console.log(obj1 === obj3); // 같은 객체(주소 0x1000)를 가리킴 → true
```

➡️ 자바스크립트 개발자는 **객체 간 비교**가 일어날 때, **내부 값이 같더라도 결과가 `true`가 아닐 수 있음**을 항상 인지해야

---

### 4. 정리

- **원시 타입**: 변수는 데이터 영역 주소를 직접 가리킴 → 새 값 할당 시 새로운 주소로 바뀜 → 독립적.
- **참조 타입**: 변수는 객체 주소(참조)를 가리킴 → 여러 변수가 같은 객체 공유 → 내부 값 수정 시 모두 영향 받음.

<br />

## 3) 자바스크립트 `Object.is`

- ES6에서 추가된 비교 방식
- 인수 두개가 동일한지 확인하고 반환
- `===`와 거의 같지만, **특수한 두 경우**에서 차이가 있음

---

1.  +0과 -0

    ```js
    +0 === -0; // true
    Object.is(+0, -0); // false
    ```

    - `===`는 +0과 -0을 같다고 봄
    - `Object.is`는 부호까지 구분해서 다르다고 판단

    ***

2.  NaN

    ```js
    NaN === NaN; // false
    Object.is(NaN, NaN); // true
    ```

    - `===`는 NaN을 자기 자신과 비교해도 false
    - `Object.is`는 NaN을 같은 값으로 취급

    ***

3.  객체 비교

    - 객체의 경우 **`===`와 `Object.is`의 차이가 없음**
    - 결국 주소(참조)가 같아야만 true

    ```js
    // 1) 동일한 리터럴 객체를 각각 생성
    Object.is({}, {}); // false (서로 다른 객체)

    // 2) 같은 참조를 공유
    const a = { hello: "hi" };
    const b = a;

    console.log(Object.is(a, b)); // true
    console.log(a === b); // true
    ```

➡️ 객체 비교는 내부 값이 같더라도 참조가 다르면 무조건 false다.  
즉, **객체 비교**는 값 비교가 아니라 "**주소 비교**”임을 항상 기억해야 한다.

<br />

## 4) 리액트에서의 동등 비교

리액트에서 사용하는 기본 동등 비교는 \*\*`Object.is`\*\*이다.
리액트는 내부적으로 `objectIs` 함수를 구현해두고, 이를 모든 비교의 기본 단위로 사용한다.

하지만 `Object.is`만으로는 객체나 배열의 **내부 값**을 감지할 수 없으므로,
리액트는 한 단계 더 나아가 **`shallowEqual`(얕은 비교)** 라는 방식을 사용한다.

---

### 1. 얕은 비교 (shallowEqual)

- 두 객체의 **1 depth 프로퍼티**만 `Object.is`로 비교
- 더 깊은 구조까지는 비교하지 않음

```js
Object.is({ x: 1 }, { x: 1 });
// 참조가 다른 객체 비교 → false (주소 다름)

shallowEqual({ x: 1 }, { x: 1 });
// 1 depth 비교 → true

shallowEqual({ x: 1 }, { x: 2 });
// 1 depth 비교 → false

shallowEqual({ x: { y: 1 } }, { x: { y: 1 } });
// 2 depth 비교 불가 → false (주소 다름)
```

- 1단계 값이 원시 타입이면 같다고 판단 (`true`)
- 내부(2 depth)에 참조 타입이 있으면 주소가 달라 `false`

---

### 2. 리액트는 왜 얕은 비교만 할까?

1. **성능 최적화**

   - props/state는 보통 트리 구조의 객체
   - 깊은 비교를 매번 하면 성능 저하 → 1 depth만 비교

2. **불변성(immutability) 철학**

   - 리액트는 “상태가 바뀌면 **새로운 객체를 만들어라**”라는 원칙을 전제
   - 그래서 얕은 비교만 해도 변경 여부를 정확히 감지 가능

---

### 3. 불변성을 지켜야 하는 이유

리액트는 얕은 비교만 하기 때문에, 참조형 데이터가 바뀌었는지 알 수 있는 유일한 방법은  
**객체의 참조(주소)가 달라지는 것**이다.

따라서 배열/객체를 직접 수정하지 않고, **새 객체를 만들어 교체**해야 한다.

```js
state.push(4); // ❌ 주소 동일 → 리액트는 변경 못 느낄 수 있음
setState([...state, 4]); // ✅ 새 주소 부여

// ❌ 객체도 직접 수정 (깊은 비교가 필요해짐)
setUser((prev) => {
  prev.name = "Danbi"; // 같은 객체 수정
  return prev;
});

// ✅ 새 객체 반환 (얕은 비교로 충분)
setUser((prev) => ({
  ...prev,
  name: "Danbi", // 새로운 객체 반환
}));
```

---

## 정리

1. 자바스크립트에는 **원시 타입**(number, string 등)과 **참조 타입**(객체, 배열 등)이 있다.

   - 원시 타입 : 값 자체를 저장하고 불변(immutable)이다.

     ```js
     let a = 10
     let b = 10
     b = 20

     메모리 구조
     // let a = 10, let b = 10
       a ──▶ (0x100) ──▶ (0x1000) ──▶ 10
       b ──▶ (0x200) ──▶ (0x1000) ──▶ 10

       // b = 20
       a ──▶ (0x100) ──▶ (0x1000) ──▶ 10
       b ──▶ (0x200) ──▶ (0x1001) ──▶ 20
     ```

   - 참조 타입 : 주소(참조)를 저장하고, 여러 변수가 같은 객체를 공유할 수 있다.

     ```js
       let obj1 = {x:1}
       let obj2 = obj1
       obj2.x = 2

       메모리 구조
       // let obj1 = {x:1}, let obj2 = obj1
         obj1 ──▶ (주소:0x300) ──▶ (주소:0x400) ──▶ { x ──▶ (주소:0x1000) ──▶ 1 }
         obj2 ──▶ (주소:0x500) ──┘

       // obj2.x = 2
         obj1 ──▶ (주소:0x300) ──▶ (주소:0x400) ──▶ { x ──▶ (주소:0x1001) ──▶ 2 }
         obj2 ──▶ (주소:0x500) ──┘
     ```

2. 동등 비교

   - `===` : 원시 타입은 값 비교, 참조 타입은 주소 비교를 한다.
   - `Object.is` : `===`와 유사하지만 `+0/-0`, `NaN` 처리에서만 차이가 있다.

     - `Object.is(+0, -0) // false`
     - `Object.is(NaN, NaN) // true`

   - 객체 비교에서는 `===`와 `Object.is` 모두 참조 주소가 같아야 true를 반환한다.
     - `Object.is({}, {}) // false` (새 객체 생성 → 서로 다른 주소)

3. 리액트 동등 비교

   - `props`와 `state`가 바뀌었는지 **Object.is + shallowEqual(얕은 비교)** 로 판단한다.
   - 얕은 비교는 객체의 **_1 depth_** 프로퍼티만 비교하고, 깊은 구조는 비교하지 않는다.

     - `shallowEqual({x:1}, {x:1})` → true (1 depth 같음)
     - `shallowEqual({x:{y:1}}, {x:{y:1}})` → false (2 depth 주소 다름)

     - 따라서 내부 값이 바뀌어도 주소가 같으면 변화가 없다고 판단할 수 있다.
       - `prev.name = "Danbi"` 같은 직접 수정 시 감지 못함

   - 이때 필요한 것이 **불변성(immutability)** 이다.

     - 배열/객체를 직접 수정하지 않고, **항상 새 객체/배열을 반환해야 한다.**
     - 그래야 참조 주소가 바뀌어 얕은 비교에서 **변경을 감지**할 수 있다.

     - `state.push(4)` ❌ vs `setState([...state, 4])` ✅
     - `prev.name = "Danbi"` ❌ vs `setUser({ ...prev, name: "Danbi" })` ✅

4. 결론: **불변성을 지켜야 얕은 동등 비교만으로도 리액트가 상태 변화를 올바르게 감지할 수 있다.**
