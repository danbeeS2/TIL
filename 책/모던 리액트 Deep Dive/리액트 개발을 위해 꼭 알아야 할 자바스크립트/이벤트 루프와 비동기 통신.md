# 이벤트 루프와 비동기 통신의 이해

## 1) 싱글 스레드 자바스크립트

- 자바스크립트(JS)는 기본적으로 **싱글 스레드** 환경에서 동작 → 한 번에 하나의 작업만 실행 가능
- “Run-to-completion” 특성 있음 → 코드 조각 하나가 실행되면 끝날 때까지 다른 작업이 끼어들지 못함
- 그러나 사용자 인터랙션, 네트워크 요청, 타이머 등 다양한 비동기 작업이 많아지면서 “동기 방식만”으로는 유저 경험이 떨어짐

## 2) 이벤트 루프(Event Loop)

- 이벤트 루프는 JS 런타임이 비동기 작업을 관리하는 메커니즘
- 콜 스택(Call Stack), 태스크 큐(Task Queue), 이벤트 루프가 함께 작동

  - 콜 스택(=호출 스택, 실행 컨텍스트 스택): 현재 수행 중인 함수/코드 블록을 추적
  - 태스크 큐(=매크로태스크 큐): 비동기 콜백 등이 준비되면 여기에 대기
  - 이벤트 루프: 콜 스택이 비면 큐에서 대기 중인 태스크를 꺼내 실행

## 3) 태스크 큐와 마이크로 태스크 큐

- 비동기 콜백들도 종류가 있음

  - **태스크 큐**: `setTimeout`, `setInterval`, I/O, 이벤트 핸들러 등 처리
  - **마이크로태스크 큐**: `Promise.then`, `Promise.catch`, `async/await` 등의 후속 처리

- 우선순위: **마이크로태스크 큐가 태스크 큐보다 우선 실행됨**

  - 콜 스택이 비면 먼저 마이크로태스크들을 처리
  - 그 다음 매크로태스크 실행

#### 예시 코드로 보는 흐름

```js
console.log("start");

setTimeout(() => {
  console.log("timeout"); // 매크로태스크
}, 0);

Promise.resolve()
  .then(() => {
    console.log("promise1"); // 마이크로태스크
  })
  .then(() => {
    console.log("promise2"); // 마이크로태스크
  });

console.log("end");
```

> 실행 순서 : `start` → `end`→ `promise1` → `promise2` →

---

### 1. 렌더링 시점

**렌더링 기회**는 마이크로태스크 처리 후에 주어지므로,  
연속된 `Promise.then` 안에서 상태를 업데이트해도 실제 화면 갱신은 그 사이사이에 일어나지 않고, **한 번에 모여서 처리된다.**

렌더링은 반드시 **마이크로태스크를 모두 비운 다음에만** 일어난다.

즉 브라우저는 매번 작업이 끝날 때마다 무조건 그리는 게 아니라, **마이크로태스크가 끝나는 타이밍에만 화면 갱신을 시도**하는 것이다.

- 이벤트 루프 규칙
  1. 콜 스택이 비면 **마이크로태스크 큐를 모두 처리**
  2. 그 다음 **렌더링 기회**
  3. 그 후 매크로태스크 큐에서 하나 꺼내 실행 → 다시 반복

#### (1) sync 버튼 (동기 코드)

```js
for (let i = 0; i <= 100000; i++) {
  sync.innerHTML = i;
}
```

1. 클릭 핸들러가 콜 스택에서 **끝까지** 실행된다.
2. 루프 내 `innerHTML` 대입은 계속 일어나지만 **그동안 페인트 없음**(블로킹).
3. 핸들러 종료 → (마이크로태스크 없음) → **렌더링 1회** 발생.

> `화면 결과`
>
> - 중간 값은 안 보이고 **마지막 값 `100000`만 보임**.

---

#### (2) macrotask 버튼 (`setTimeout`)

```js
for (let i = 0; i <= 100000; i++) {
  setTimeout(() => {
    macrotask.innerHTML = i;
  }, 0);
}
```

1. 클릭 핸들러가 동기 실행되며, `setTimeout` 콜백 **100000개가 태스크 큐로 예약**됨.
2. 핸들러 종료 → 콜 스택 비어짐.
3. 이벤트 루프 한 사이클:

   1. 태스크 큐에서 콜백 하나 꺼냄 (`innerHTML = 0`)
   2. 마이크로태스크 큐 확인 → 비어 있음
   3. 브라우저 렌더링 기회 발생 → 화면에 `0` 표시

4. 다음 사이클:

   1. 태스크 큐에서 다음 콜백 실행 (`innerHTML = 1`)
   2. 마이크로태스크 큐 확인 → 비어 있음
   3. 렌더링 기회 → 화면에 `1` 표시

5. 이런 식으로 `100000`까지 반복.

> `화면 결과`
>
> - 콜백 1개 실행 → (그 사이 마이크로태스크 없으면) **렌더링 기회** → 다음 콜백 … 반복
> - **0 → 1 → 2 → … → 100000** 처럼 **숫자가 점진적으로 올라가는 모습**
> - (실제로는 타이머 최소 지연/스로틀링 때문에 약간 건너뛰거나 묶여 보일 수 있음)

---

#### (3) microtask 버튼 (`queueMicrotask`)

```js
for (let i = 0; i <= 100000; i++) {
  queueMicrotask(() => {
    microtask.innerHTML = i;
  });
}
```

1. 클릭 핸들러가 동기 실행되며, `queueMicrotask` 콜백 **100000개가 마이크로태스크 큐로 예약**됨.
2. 핸들러 종료 → **마이크로태스크 큐를 전부 비울 때까지 실행**(중간에 렌더링 기회 없음).
3. 마이크로태스크가 모두 끝난 뒤에야 **렌더링 1회**.

> `화면 결과`
>
> - 중간 값은 안 보이고 **마지막 값 `100000`만 보임**
> - 마이크로태스크를 너무 많이 넣으면 **UI가 멈춘 것처럼** 느껴질 수 있음 (마이크로태스크 굶주림)

> `마이크로태스크 굶주림(Microtask starvation)`  
> : 마이크로태스크가 너무 많이 쌓여서 브라우저가 렌더링할 기회를 잃어버리는 상황
