# 클로저 (Closure)

## 1) 클로저가 중요한 이유

> 리액트의 클래스형 컴포넌트는 클래스, 프로토타입, `this`를 이해해야 한다면,  
> 함수형 컴포넌트는 **클로저(Closure)** 이해가 필수다.

함수형 컴포넌트 구조, 훅(hook)의 동작 원리, 의존성 배열, `useState`, `useEffect` 등의 작동 원리는 모두 **클로저에 기반하고 있다**.

## 2) 클로저의 정의

클로저란 “함수와 그 함수가 선언된 **렉시컬 스코프**(어휘적 환경)의 조합”이다.

즉, 함수가 호출되는 위치가 아니라 **함수가 선언된 위치**에 따라 스코프가 결정된다는 것이다.

```js
function add() {
  const a = 10;
  const b = 10;

  // 클로저
  function innerAdd() {
    const b = 20;
    console.log(a + b); // 선언된 렉시컬 환경 기준으로 접근
  }
  innerAdd(); // 30
}
add();
```

---

## 3) 클로저의 작동 원리

- 자바스크립트는 **렉시컬 스코프(정적 스코프)** 기반 → 함수가 선언된 환경에서 상위 스코프가 결정된다.
- 모든 함수는 암묵적으로 **내부 슬롯 `[[Environment]]`** 에 정의된 시점의 상위 스코프를 저장한다.
- 여기에서 계속 참조하고 있기 때문에 GC(가비지 콜렉팅)의 대상이 되지 않는다.
- 내부 함수(클로저)가 외부 함수보다 오래 살아남는 경우에도, `[[Environment]]` 덕분에 외부 변수에 접근할 수 있다.

```js
function outerFunction() {
  var x = "hello";
  function innerFunction() {
    console.log(x);
  }
  return innerFunction;
}

const inner = outerFunction();
inner(); // 'hello'
```

- `inner`는 `outerFunction` 실행이 끝난 이후에도 `x`에 접근할 수 있다.
- 이유는 `inner`가 `x`가 존재하던 렉시컬 환경을 기억하고 있기 때문입니다.

---

## 4) 클로저의 활용과 특징

1. **정보 은닉 및 캡슐화**
   외부 상태(변수)를 감추고, 특정 함수만 상태에 접근, 변경할 수 있도록 한다.

2. **리액트 상태 유지**

   - `useState`는 클로저의 원리를 사용함

   ```js
   function Component() {
     const [state, setState] = useState(); // useState 함수 종료됨

     function handleClick() {
       setState((prev) => prev + 1); // 클로저 (외부 변수 state를 기억함)
     }
   }
   ```

---

## 5) 주의할 점

### 1. `var`와 클로저

```js
for (var i = 1; i < 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}
```

- 실행 과정

  1. `for`문이 돌면서 `setTimeout`을 4번 등록

  - `i=1` → 1초 뒤 실행할 콜백 등록
  - `i=2` → 2초 뒤 실행할 콜백 등록
  - `i=3` → 3초 뒤 실행할 콜백 등록
  - `i=4` → 4초 뒤 실행할 콜백 등록

  2.  그런데! `var`는 **함수 스코프**라서 `i`가 **하나만 존재**
      → 반복문이 끝난 시점에 `i`는 이미 `4`에서 증가해 **5**가 되어 있음

  3.  나중에 `setTimeout`이 실행될 때, 모든 콜백이 참조하는 건 동일한 `i` → 즉, `5`

      ```
      5 // 1초 뒤
      5 // 2초 뒤
      5 // 3초 뒤
      5 // 4초 뒤
      ```

---

#### 해결 방법 1. `let` 사용 (블록 스코프)

```js
for (let i = 1; i < 5; i++) {
  setTimeout(() => {
    console.log(i);
  }, i * 1000);
}
```

- 실행 과정

  1. `for`문이 돌면서 `setTimeout`을 4번 등록

  - `i=1` → 1초 뒤 실행할 콜백 등록
  - `i=2` → 2초 뒤 실행할 콜백 등록
  - `i=3` → 3초 뒤 실행할 콜백 등록
  - `i=4` → 4초 뒤 실행할 콜백 등록

  2. `let`은 블록 스코프를 가지므로, 각 반복마다 **새로운 i**가 생성됨

  ```
  1   // 1초 뒤
  2   // 2초 뒤
  3   // 3초 뒤
  4   // 4초 뒤
  ```

---

#### 해결 방법 2. IIFE(즉시 실행 함수)로 스코프 감싸기

```js
for (var i = 1; i < 5; i++) {
  setTimeout(
    // IIFE 실행, 매개변수 sec에 현재 i 값 복사
    (function (sec) {
      // 반환된 함수가 클로저
      return function () {
        console.log(sec);
      };
    })(i),
    i * 1000
  );
}
```

- 실행 과정

  1. 매 반복마다 IIFE가 즉시 실행됨
  2. `i` 값이 IIFE의 매개변수 `sec`으로 전달
  3. IIFE는 `sec`을 기억하는 **새로운 클로저**를 반환
  4. `setTimeout`은 이 클로저를 콜백으로 등록 → 실행될 때마다 각기 다른 `sec` 참조

- `i`는 하나만 존재하지만,
- `sec`은 매 반복마다 **새 스코프에 캡처**되므로 안전하게 1,2,3,4가 출력된다.

  ```
  1   // 1초 뒤
  2   // 2초 뒤
  3   // 3초 뒤
  4   // 4초 뒤
  ```

---

### 2. 클로저의 성능 및 메모리 관리 주의사항

- 메모리 낭비 가능성

  - 클로저가 선언된 순간, 내부 함수는 외부 함수의 선언 당시 환경을 기억해야 한다. 따라서 사용 여부와 상관없이 외부 변수가 메모리에 남는다.
  - 불필요한 변수까지 함께 저장되면 메모리를 불필요하게 점유한다.

- 성능 저하 위험

  - 참조를 오래 유지하면 가비지 컬렉터가 수거하지 못해 누수가 생길 수 있다.
  - 스코프 체인이 길어질수록 변수 접근 비용도 커진다.

- 최적화 방법

  - 클로저에는 꼭 필요한 변수만 남겨두고, 나머지는 제거한다.
  - 클로저를 지역적·한정된 범위 안에서 사용해 관리한다.

클로저는 강력한 기능이지만, 메모리와 성능 문제를 야기할 수 있어 꼭 필요한 경우에만 사용해야 한다
