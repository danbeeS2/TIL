# 선택이 아닌 필수, 타입스크립트

- 타입스크립트는 이제 선택 사항이 아니라 “꼭 있으면 좋은” 기술
- 리액트 같은 복잡한 UI 라이브러리/생태계에서는 타입이 코드 안정성과 유지보수성에 크게 기여함
- 타입스크립트를 잘 쓰려면 “타입을 명확히 하고, 가능한 좁게 유지하고, 타입 가드를 적극 활용”하는 태도가 중요함

### 1) 타입스크립트란?

- TypeScript는 “타입(type)” 문법을 자바스크립트에 더한 언어. 자바스크립트의 상위집합(superset)
- 자바스크립트는 **동적 타입 언어**라서, 타입 에러를 코드 실행(run-time) 시점에만 발견하는 경우가 많음. ⇒ 규모가 커질수록 버그 가능성↑

- 타입스크립트는 **정적 타입 검사** 를 빌드 시점(build time)에 해줌 → 개발 중 에러를 조기에 잡을 수 있어서 안정성이 높아짐

---

### 2) 리액트에서 자주 쓰이는 TS 개념

#### 1. `any` 대신 `unknown` 사용

- `any`는 타입스크립트의 타입 안전성을 버리는 것이나 마찬가지라서 가능하면 안 쓰는 게 좋음
- 아직 타입을 특정할 수 없을 경우 → `unknown`을 쓰고, 타입 가드로 좁히는 방식이 더 안전함

  - `unknown`은 toptype 이다.

  ***

#### 2. `never` 타입 사용

- **값이 존재할 수 없는 타입(공집합)** 을 나타냄

  - props를 전혀 받지 않는 컴포넌트라면 `Record<string, never>` 같은 식으로 사용

    ```ts
    type Props = Record<string, never>;  // { [key: string]: never }
    type State = { counter: 0 };

    class SampleComponent extends React.Component<Props, State> {
      constructor(props: Props) {
        super(props);
        this.state = { counter: 0 };
      }
      render() {
        return <div>{this.state.counter}</div>;
      }
    }

    // 사용
    <SampleComponent /> // OK (빈 객체)
    <SampleComponent hello="world" /> // Error: string은 never에 할당 불가

    ```

- switch-case 같은 구조에서 모든 케이스가 처리되었음을 나타내는 용도

  ```ts
  type Shape = "circle" | "square";

  function getArea(shape: Shape): number {
    switch (shape) {
      case "circle":
        return Math.PI * 1 * 1;
      case "square":
        return 1 * 1;
      default:
        // 여기서 shape는 절대 올 수 없는 타입이어야 함
        const _exhaustiveCheck: never = shape;
        return _exhaustiveCheck;
    }
  }
  ```

  1. `Shape` 타입은 `"circle" | "square"` 두 가지뿐
  2. `switch`에서 `"circle"`과 `"square"`를 처리했으니, 사실상 `default`는 절대 실행될 일이 없음.
     - 그래서 `default` 블록에서 `shape`의 타입은 `never`이어야 한다.
  3. 그런데 만약 타입이 늘어나서 `"triangle"`이 추가되었는데, switch에서 처리하지 않았다면?

     - `shape`는 `never`가 아니라 `"triangle"`이 될 수 있음.
     - 따라서 `const _exhaustiveCheck: never = shape;` 이 줄에서 **타입 에러 발생**
     - → “새로운 케이스를 처리하지 않았다”는 걸 컴파일 타임에 잡아줌.

  ***

#### 3. 타입 가드(Type Guard)

- union 타입이나 `unknown` 타입 등을 더 구체적 타입으로 좁히는 코드

  - `instanceof` : 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인
  - `typeof` : 특정 요소의 자료형 확인
  - `'key' in object` : 어떠한 객체에 키가 존재하는지 확인
  - `keyof` : 객체 타입의 **키 이름**들을 union 타입으로 뽑아내는 연산자
    - `K extends keyof T` → `K`는 반드시 `T`의 키여야 함
  - 함수 인자 타입, 오류 객체(catch 그이) 다룰 때 등

  ***

#### 4. 제네릭(Generic)

- 함수나 클래스 내부에서 **단일 타입이 아닌 다양한 타입에 대응할 수 있도록** 도와주는 도구

- 함수나 컴포넌트가 다양한 타입을 처리할 때, 코드 중복 없이 타입 유연성을 유지하게 해줌

  ```ts
  function getItem<T>(list: T[]): [T, T] {
    return [list[0], list[1]];
  }
  ```

  - `<T>` : **제네릭 타입 매개변수 선언**
  - `list: T[]` : 매개변수 `list`는 **T 타입의 배열**
  - `[T, T]` : 반환값은 **T 타입 요소 2개를 담은 튜플**

    ***

#### 5. 인덱스 시그니처 (Index Signature)

- 객체의 **key/value 패턴**을 타입으로 정의하는 문법
- 객체 속성 이름을 미리 다 알 수 없을 때 사용
- ⇒ **객체가 임의의 키를 가질 수 있다는 걸 타입으로 정의하는 문법**으로, key/value 패턴을 강제할 수 있다.

  ```ts
  type UserAges = {
    [key: string]: number; // 모든 string 키 → number 값
  };

  const ages: UserAges = {
    alice: 25,
    bob: 30,
    // carol: "young"   // 오류: number만 가능
  };
  ```

  - 여기서 인덱스 시그니처는 **모든 string 키의 값은 number여야 한다**고 강제함

---

- 리액트에서 **props를 동적으로 받아야 하는 상황**에서 유용함

  ```ts
  type Props = {
    // 모든 string 키 → string 또는 number 값
    [key: string]: string | number;
  };

  function DynamicProps(props: Props) {
    return (
      <div>
        {Object.entries(props).map(([key, value]) => (
          <p key={key}>
            {key}: {value}
          </p>
        ))}
      </div>
    );
  }

  // 사용 예시
  <DynamicProps name="Danbi" age={25} job="Frontend Developer" />;
  ```

  → 어떤 props가 들어올지 알 수 없지만, **string/number만 허용**하는 제약을 줄 수 있음.

  #### 주의사항

  - 인덱스 시그니처` { [key: string]: T }`는 유용하지만 너무 넓다.
  - `Record<유니온, T>`나 `keyof`같은 도구를 활용해 **키 집합을 좁히고 안전성을 확보**하는 게 좋다.

  1. 리터럴 유니온 + `Record`

     ```ts
     type Field = "email" | "password" | "nickname";
     type FormValues = Record<Field, string>;

     const form: FormValues = {
       email: "a@b.com",
       password: "1234",
       nickname: "Danbi",
       // phone: "010..." ❌ Error: 정의되지 않은 키
     };
     ```

  2. `as const` + `keyof typeof`

     ```ts
     const fields = ["email", "password", "nickname"] as const;
     type Field = (typeof fields)[number]; // "email" | "password" | "nickname"
     type FormValues = Record<Field, string>;
     ```

  3. `keyof`로 안전한 키 접근

     ```ts
     type Hello = { hello: string; hi: string };
     type HelloKeys = keyof Hello; // "hello" | "hi"

     const obj: Hello = { hello: "안녕", hi: "하이" };

     (Object.keys(obj) as HelloKeys[]).forEach((k) => {
       console.log(obj[k]); // string
     });
     ```

---

### 3) 타입스크립트 전환 가이드

- 작은 프로젝트라도 타입을 조금씩 적용해보기 (컴포넌트 단위로 타입 선언)
- 코드 중 어느 부분이 타입을 알기 힘든지 찾아내고, 그 부분을 `unknown` + 타입 가드 식으로 개선
- 리액트 + 타입스크립트 환경 설정 (tsconfig, eslint 설정) 정비
- `@types/*` 패키지를 통해 외부 라이브러리 타입 확보
