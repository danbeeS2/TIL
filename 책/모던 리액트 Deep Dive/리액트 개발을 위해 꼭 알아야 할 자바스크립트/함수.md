# 함수

## 1) 함수란?

- 작업을 수행하거나 값을 계산하는 과정을 실행 단위로 만든 코드 블록
- 리액트 컴포넌트도 함수
  - 매개변수: `props` (단일 객체)
  - 반환값: JSX

## 2) 함수를 선언하는 4가지 방법

자바스크립트에서 함수를 선언하는 방식은 여러 가지가 있으며, 각각 특징과 동작 방식이 다르다.

### 1. 함수 선언문

```js
add(1, 2); // 3 (호이스팅)

function add(a, b) {
  return a + b;
}
```

- 일반 문(statement)로 분류된다.
- 선언과 동시에 호이스팅되어, 선언 위치보다 앞에서도 호출이 가능하다.

---

### 2. 함수 표현식

```js
add(1, 2); // ReferenceError (호이스팅 X)
const add = function (a, b) {
  return a + b;
};
```

- 자바스크립트에서 함수는 **일급 객체** 이기 때문에 표현식으로 사용 가능하다.
  > - **함수는 일급 객체**이다.
  >   - 인자로 전달 가능
  >   - 반환값 가능
  >   - 변수에 할당 가능
- 표현식으로 작성된 함수는 변수 스코프 규칙을 따른다.
  - `var`로 선언하면 호이스팅 시 `undefined`가 되고,
  - `let`/`const`로 선언하면 선언 전에 접근 시 `ReferenceError`가 발생한다.
- 따라서 함수 표현식은 함수 선언문과 달리 **정의 이후에만 안전하게 사용**할 수 있다.

---

### 3. Function 생성자

```js
const add = new Function("a", "b", "return a + b");
```

- 문자열을 받아 실행 가능한 함수를 만드는 방식이다.
- 클로저가 생성되지 않고, 가독성 및 성능 측면에서 좋지 않다.
- `eval` 만큼이나 실제 개발에서는 거의 사용되지 않는다.

---

### 4. 화살표 함수

```js
const add = (a, b) => {
  return a + b;
};

const add = (a, b) => a + b;
```

- `constructor`로 사용할 수 없다 → 생성자 함수로 활용 불가
- `arguments` 객체가 존재하지 않는다
- `this` 바인딩이 없음

  - 호출 시점이 아니라 **선언 시점**의 상위 스코프의 `this`를 그대로 따른다
  - 따라서 별도의 바인딩 작업 없이도 `this`를 안전하게 사용할 수 있어 콜백 함수에서 유용

  ***

#### `this` 바인딩 비교

- **일반 함수** : `this`가 **호출 시점에 동적으로 결정** 된다.
  - → `this`가 호출한 대상에 따라 바뀌므로 주의 필요
- **화살표 함수** : `this`가 **선언 시점에 상위 스코프 기준으로 정적으로 결정**된다.
  - → `this`가 정적으로 고정되므로 콜백에서 안전하게 사용 가능

```js
// 일반 함수
const obj = {
  name: "Danbi",
  foo: function () {
    function normal() {
      console.log(this.name);
    }
    normal();
  },
};
obj.foo(); // strict 모드: undefined / 비엄격 모드: window.name

// 화살표 함수
const obj = {
  name: "Danbi",
  foo: function () {
    const arrow = () => console.log(this.name);
    arrow();
  },
};
obj.foo(); // "Danbi" (선언된 위치(= foo 함수)의 this(obj)를 가져옴)
```

## 3) 다양한 함수 살펴보기

### 1. 즉시 실행 함수 (IIFE)

- 정의와 동시에 실행되는 함수

  ```js
  (function (a, b) {
    return a + b;
  })(10, 24);
  ```

- 글로벌 변수 오염 없이 **독립적인 스코프**를 제공

### 2. 고차 함수 (Higher-order Function)

- 함수를 인자로 받거나 반환하는 함수

  ```js
  // 1. 함수를 매개변수로 받는 고차함수
  [1, 2, 3].map((item) => item * 2);

  // 2. 함수를 반환하는 고차함수
  const add = function (a) {
    return function (b) {
      // 클로저
      return a + b;
    };
  };

  add(3)(4); // 7
  ```

- 고차 함수 컴포넌트를 만들면, 컴포넌트 내부에서 공통으로 관리하는 로직을 분리해 관리할 수 있음 ⇒ **컴포넌트 리팩터링에도 활용 가능**

## 4) 함수 설계 시 주의사항

#### 1. 함수의 **부수 효과(side-effects) 최소화** 하라

- 함수 내부에서 외부 상태를 바꾸는 일을 피하고, 순수 함수(pure function)를 지향해야 한다.
- 부수 효과는 피할 수 없는 요소이지만, 최대한 억제할 수 있는 방향으로 함수를 설계해야 한다.
- 리액트에서도 `useEffect` 최소화 → 컴포넌트의 안정성과 예측 가능성 ↑

#### 2. 가능한 한 **함수를 작게 만들어라**

- 하나의 함수가 너무 많은 일을 하지 않도록 하는 것이다.
- 작은 단위로 나누면 재사용성과 유지보수성 ↑

#### 3. 누구나 **이해하기 쉬운 이름**을 붙여라

- 가능한 한 함수의 이름은 간결하고 이해가기 쉽게 붙이는 것이 좋다.
- 콜백 함수에 네이밍을 붙이면 가독성에 도움이 된다.
  ```js
  useEffect(function apiRequest() {
    // do something
  }, []);
  ```
  - useEffect 코드를 유심히 보지 않아도 어떤 일을 하는지, 어떻게 동작하는지 알 수 있음
