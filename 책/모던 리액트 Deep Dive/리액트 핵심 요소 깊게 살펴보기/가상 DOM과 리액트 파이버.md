# 2.2 가상 DOM과 리액트 파이버

리액트는 실제 DOM이 아닌 가상 DOM을 운영한다.

## 1) DOM과 브라우저 렌더링 과정

- 브라우저 렌더링 과정

  1. HTML 파일 다운로드
  2. HTML 파싱 → DOM 트리 생성 + CSS 파일 다운로드
  3. CSS 파싱 → CSSOM (CSS 트리) 생성
  4. DOM 트리 순회 (사용자 눈에 보이는 노드만 순회함 `dispaly:none` 같은 요소는 방문X)
  5. 렌더 트리 구성
  6. 레이아웃 : 브라우저 화면의 어느 좌표에 나타나야 하는지 계산하는 과정
  7. 페인팅 : 레이아웃 단계를 거친 노드에 색과 같은 실제 유효한 모습을 그리는 과정
  8. 합성 : 화면에 그는 과정

> ※ `레이아웃` 단계를 거치면 필연적으로 `리패인팅`이 발생함

- DOM 변경은 레이아웃·페인팅을 다시 유발하기 때문에 **비용이 큼**.
- UI 업데이트가 잦아진 현대 웹 환경에선 “최소한의 변경만 반영”하는 전략이 필요.

<br />

## 2) 가상 DOM의 탄생 배경

**가상 DOM** : 실제 DOM을 직접 다루지 않고, **메모리에 가상의 트리 구조를 만들어 변경 사항을 관리하는 방식**  
 ⇒ 가상 DOM에서 변경 사항을 먼저 계산 후, 실제 DOM에는 필요한 부분만 반영(렌더링 최소화)

- **등장 배경**

  - 직접 DOM 조작은 복잡하고 성능 부담이 크다.
  - 리액트는 **UI를 값(virtual DOM 객체)** 으로 표현 → 이전 스냅샷과 비교(diffing) 후 실제 DOM에 최소 변경만 반영
  - 즉, 가상 DOM은 “빠른 성능” 자체가 목적이 아니라, **선언적으로 UI를 다루고 변경을 자동으로 최소화**하기 위한 추상화 계층

  > ※ **가상 DOM 방식**은 대부분의 상황에서 <u>웬만한 애플리케이션을 개발할 수 있을 만큼 충분히 빠른 것</u>이지, 항상 실제 DOM 방식보다 빠른 것은 아니다.

<br />

## 3) 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트의 가상 DOM과 렌더링 최적화를 가능하게 해주는 것이 바로 **리액트 파이버(React Fiber)** 이다.

### 1. 리액트 파이버란?

- React 16부터 도입된 새로운 **재조정(reconciliation) 엔진**
  - 기존: 재귀 호출 기반 스택 구조 → 한 번 시작하면 끝날 때까지 중단 불가 (UI 멈춤 문제 발생)
  - 파이버: 작업을 잘게 쪼개서 우선순위에 따라 나눠 실행 가능 (협력적 스케줄링)
- 작업을 잘게 쪼개고, 우선순위를 매겨 중단/재개 가능하게 만든 구조

> 재조정: 어떤 부분을 새롭게 렌더링해야 하는지 실제 DOM과 가상 DOM을 비교하는 알고리즘

---

#### ① Fiber Node 구조

- 각 컴포넌트/DOM 요소를 표현하는 “작은 단위 객체” (`Fiber Node`로 관리)
- 링크드 리스트 형태로 연결 (`child` / `sibling` / `return` 포인터)

  - 파이버는 `child`를 하나만 가짐
  - 대신 형제 노드를 `sibling` 포인터로 이어 붙여서 **여러 자식처럼 표현함**
  - 그래서 탐색할 때는 항상
    1. `child`로 먼저 내려가고
    2. 없으면 `sibling`으로 가고
    3. 그것도 없으면 `return`으로 올라가는 식으로 순회
  - → 트리를 순회하면서 작업을 나눠서 처리 가능

  ***

#### ② 동작 과정

1. **렌더 단계 (재조정 단계)** : 비동기 작업

   - 가상 DOM 생성, Fiber 트리 비교
   - `workInProgress` 트리에 변경 사항 기록
   - 이 단계는 **중단 가능**

2. **커밋 단계** : 동기 작업

   - 실제 DOM에 반영
   - 이 단계는 **중단 불가**

     ***

#### ③ 장점

- 작업을 잘게 쪼개 중단/재개 가능 → 브라우저 렌더링을 막지 않음
- 우선순위 기반 처리: 사용자 입력/애니메이션 같은 긴급 작업 먼저 실행
- React의 Concurrent Mode, Suspense 등의 기반이 됨

---

### 2. 리액트 파이버 트리

- 각 컴포넌트 노드를 **Fiber 객체**로 관리.
- Fiber는 `child`, `sibling`, `return` 포인터를 가져서 **연결 리스트 형태의 트리**를 구성.

- 두 개의 트리를 유지

  - **current**: 현재 화면에 반영된 트리
  - **workInProgress**: 작업 중인 새 트리

- 업데이트 완료 시 두 트리를 교체 → **더블 버퍼링**

> `더블 버퍼링`
>
> - 보이지 않는 곳에서 그다음으로 그려야 할 그림을 미리 다 그린 다음, 이것이 완성되면 현재 상태를 새로운 그림으로 바꾸는 기법
> - 다 그리지 못한 불완전한 트리를 보여주지 않기 위해 사용

---

### 3. 파이버의 작업 순서

리액트는 파이버 트리에서 **각 노드(Fiber 객체)** 를 방문하며 작업을 한다.  
이때 두 가지 함수가 핵심이다.

- `beginWork(fiber)` : 파이버 **작업 시작**
- `completeWork(fiber)` : 파이버 **작업 완료**

#### ① 동작 순서

1. **`beginWork()` 실행 (자식으로 내려감)**

   - 현재 파이버 노드에서 필요한 작업(업데이트, diff 등)을 수행.
   - 자식이 있으면 **자식 파이버로 이동**.

2. **더 이상 자식이 없을 때까지 반복**

   - 자식 파이버가 없을 때 멈춤.
   - 이제는 **밑바닥(leaf node)** 에 도착한 상태.

3. **`completeWork()` 실행 (형제로 이동하거나 부모로 올라감)**

   - 현재 파이버 작업을 완료 처리.
   - 형제가 있으면 형제로 이동.
   - 형제도 다 끝났으면 부모로 `return`해서 “나 다 끝났어” 하고 보고.

4. **위 과정을 반복**

   - 결국 모든 파이버 노드를 방문하면서 begin → complete 흐름을 반복.
   - 이렇게 해서 **WorkInProgress 트리**가 완성됨.

---

#### ② 예시

```jsx
<App>
  <Header />
  <Content>
    <Article />
    <Footer />
  </Content>
</App>
```

1. `App` → beginWork → 자식(`Header`)으로 내려감
2. `Header` → 자식 없음 → completeWork(`Header`) → 형제(`Content`)로 이동
3. `Content` → beginWork → 자식(`Article`)으로 내려감
4. `Article` → 자식 없음 → completeWork(`Article`) → 형제(`Footer`)로 이동
5. `Footer` → completeWork(`Footer`) → 형제 없음 → 부모(`Content`)로 올라감
6. `Content` → completeWork(`Content`) → 부모(`App`)로 올라감
7. `App` → completeWork(`App`) → 트리 전체 완료

- `파이버 트리(포인터 기준)`

  ```
  App
  └─ child → Header
      sibling → Content
                    └─ child → Article
                      sibling → Footer
  ```

---

- 파이버 작업 순서는 **깊이 우선 탐색(DFS)**과 유사함
- `beginWork` 단계에서 **내려가며 작업 시작**,  
  `completeWork` 단계에서 **올라오며 작업 완료**
- 자식 → 형제 → 부모 순서로 전부 순회하면서 **WorkInProgress 파이버 트리**를 완성한다.
- 이게 끝나야 **커밋 단계**에서 실제 DOM 변경이 일어난다.

<br />

## 4) 실제 동작 예시 (setState 업데이트)

### 1. 업데이트 요청

```jsx
function Counter() {
  const [count, setCount] = useState(0);
  return <p>{count}</p>;
}
```

버튼 클릭으로 `setCount(1)` 호출 → 해당 컴포넌트 Fiber에 업데이트 스케줄링.

### 2. 더블 버퍼링

- 현재 화면 = **current Fiber tree**
- 업데이트 발생 시 → current를 참고해 **workInProgress Fiber tree** 생성.
- 새로 “다 만드는 것”이 아니라, **기존 Fiber와 DOM을 최대한 재활용**.

### 3. 재활용과 갱신

- **재활용**: 같은 타입의 Fiber (`<p>`는 여전히 `<p>`) → `stateNode`(DOM 노드)는 그대로 둠
- **갱신**: `pendingProps`, `memoizedProps`, hooks state queue 등 내부 속성 값만 새로 반영

### 4. beginWork / completeWork

1. `beginWork`에서 새 props/state 계산, children Fiber 준비
2. `completeWork`에서 effect 수집 (DOM 변경 필요 여부 기록)
3. commit 단계에서 실제 DOM 업데이트

<br />

## 5) 파이버와 가상 DOM

- 가상 DOM은 **UI를 객체로 표현한 값**
- 파이버는 **그 값을 기반으로 실제 렌더링을 스케줄링하고 재조정하는 내부 아키텍처**

- ⇒ **가상 DOM은 선언적 UI 표현**.  
   **파이버는 이를 효율적으로 처리하는 실행 엔진**

  <br />

## 6) 정리

- **가상 DOM**: UI를 값으로 표현, diffing으로 최소 변경 계산

- **Fiber**: 그 계산 과정을 더 잘게 쪼개고 우선순위 기반으로 효율적으로 스케줄링하는 엔진

- **setState 업데이트**: current Fiber를 참고해 workInProgress Fiber를 만들고, DOM은 재활용, 내부 값만 갱신

- ⇒ UI는 값으로 선언적으로 표현되고, React는 Fiber를 통해 **최소 DOM 변경 + 중단 가능한 작업 처리**를 보장한다.
