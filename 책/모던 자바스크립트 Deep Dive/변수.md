# 변수

## 1) 변수의 정의 및 필요성

변수는 `값을 저장하고 참조하는 매커니즘`으로, **값의 저장된 메모리 공간을 가르키는 상징적인 이름**이다.  
자바스크립트 엔진은 변수를 선언하면 해당 이름과 연결된 메모리 공간을 확보하고, 변수명과 그 메모리 주소를 매핑한다.

따라서 변수명을 통해 값을 요청하면, 자바스크립트 엔진은 이 매핑 정보를 이용해  
**변수 이름 → 메모리 주소 → 저장된 값** 의 순서로 접근하여 최종 값을 반환한다.

- 변수는 '데이터를 담는 상자'라기보다는 **'메모리 주소에 붙인 이름표'** 에 가깝다.
- 코드는 컴퓨터에게 내리는 명령이지만 동시에 **개발자를 위한 문서**이기도 하다.  
  명확한 변수 네이밍은 코드를 이해하기 쉽게 만들며, 협업과 품질 향상에도 큰 도움이 된다.

## 2) 식별자

식별자(identifier)는 어떤 값을 구별하여 식별할 수 있는 고유한 이름을 말한다.  
변수 이름을 식별자라고도 하며, 식별자는 **값 자체가 아니라 값이 저장된 메모리 주소를 기억**한다.  
즉, 식별자를 통해 값을 구별한다는 것은 식별자가 기억하고 있는 메모리 주소를 이용해, 해당 주소에 저장된 값에 접근한다는 의미다.

식별자라는 용어는 **변수 이름에만 국한되지 않는다.**

- 변수, 함수, 클래스의 이름은 모두 식별자다.
- 즉, 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름은 모두 식별자라고 할 수 있다.

식별자는 반드시 **선언**을 통해 자바스크립트 엔진에 그 존재를 알려야 하며, 그래야만 이후 코드에서 참조할 수 있다.

## 3) 변수 선언과 실행 시점

### 1. 변수 선언 과정

변수 선언은 **변수를 생성하는 것**을 말한다.  
즉, 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 해당 메모리 주소를 연결하여 값을 저장할 수 있도록 준비하는 과정이다.  
이렇게 확보된 메모리 공간은 해제되기 전까지 다른 용도로 사용할 수 없으므로 안전하게 사용할 수 있다.

변수를 사용하려면 반드시 선언이 필요하다.
선언하지 않은 식별자에 접근하면 `ReferenceError`가 발생한다.

> **`ReferenceError(참조 에러)`**  
> 식별자를 통해 값을 참조하려 했지만 자바스크립트 엔진이 등록된 식별자를 찾을 수 없을 때 발생하는 에러

---

### 2. 변수 호이스팅

```js
console.log(score); // undefined
var score;
```

겉보기에는 참조 에러가 발생할 것 같지만, 실제로는 `undefined`가 출력된다.  
그 이유는 **변수 선언이 런타임 이전 단계(= 소스코드 평가 과정)에서 먼저 실행되기 때문**이다.

> **소스코드 평가 과정**  
> 소스코드 실행을 위한 준비 단계로, **자바스크립트 엔진은** 변수 선언을 포함한 **모든 선언문**을 **먼저 처리한다**.  
> 해당 단계가 끝나면 비로소 선언문을 제외하고 소스코드를 한 줄 씩 순차적으로 실행된다. (런타임 단계)

따라서 변수 선언문이 코드의 어디에 있든 상관없이 항상 먼저 실행된다.  
이로 인해 **변수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작**하는데, 이를 **`호이스팅(hoisting)`** 이라고 한다.

---

### 3. `var`, `let`, `const` 키워드

변수를 선언할 때는 `var`, `let`, `const` 키워드를 사용한다.

> #### 변수의 선언 과정
>
> 변수 선언 과정은 두 단계로 나눌 수 있다.
>
> 1. **선언 단계** : 변수 이름을 실행 컨텍스트에 등록하여 자바스크립트 엔진에 존재를 알림.
> 2. **초기화 단계** : 메모리 공간을 확보하고 필요 시 `undefined`를 할당.  
>    (`var`는 자동 초기화, `let/const`는 선언만 하고 초기화는 별도로 필요)

<br />

```js
var x;
console.log(x); // undefined

let y;
console.log(y); // ReferenceError
```

- **`var` 키워드**

  - 함수 스코프(Function scope)를 가진다.
  - 선언과 동시에 자동으로 `undefined`로 초기화 된다.
  - 선언과 초기화가 함께 호이스팅되므로, 선언문 이전에도 참조 가능 → 값은 `undefined`

- **`let` 키워드**

  - 블록 스코프(Block scope)를 가진다.
  - 선언만 호이스팅되고, 초기화는 실제 코드 실행 시점에 이루어진다.
  - 초기화 전 구간에서는 **일시적 사각지대(Temporal Dead Zone, TDZ)**에 걸리므로, 참조 시 `ReferenceError`가 발생한다.

- **`const` 키워드**
  - 블록 스코프(Block scope)를 가진다.
  - 반드시 선언과 동시에 초기화 해야 한다.
  - 재할당이 불가능하다.

---

> #### `var` vs `let/const` 호이스팅 차이
>
> | 구분      | 선언 시점 (평가 단계) | 초기화 시점                                 | 호이스팅 시 실제 동작                                                      | 선언문 이전 접근          |
> | --------- | --------------------- | ------------------------------------------- | -------------------------------------------------------------------------- | ------------------------- |
> | **var**   | O (호이스팅됨)        | O (평가 단계에서 `undefined`로 자동 초기화) | 선언 + 초기화가 함께 끌어올려진 것처럼 동작                                | 가능 (값은 `undefined`)   |
> | **let**   | O (호이스팅됨)        | X (런타임에 실행)                           | 선언만 끌어올려지고 초기화는 나중에 실행 → **TDZ** 발생                    | 불가능 (`ReferenceError`) |
> | **const** | O (호이스팅됨)        | X (런타임에 실행, 반드시 동시에 초기화)     | 선언만 끌어올려지고 초기화는 런타임에 선언문을 만날 때 수행 → **TDZ** 발생 | 불가능 (`ReferenceError`) |

📌 정리

- 모든 선언문(`var`, `let`, `const`, `function`, `class` 등)은 호이스팅된다.
- 단, var는 **선언 + 초기화(undefined)** 가 함께,  
  let/const는 **선언만 호이스팅되고 초기화는 런타임에 진행** → 그래서 TDZ 구간이 생김.

- 즉, 차이점은 `초기화`가 **평가 단계에서 같이 수행되는가(var)**, 아니면 **런타임에 별도로 수행되는가(let/const)**다.
- 이 때문에 `var`는 선언문 이전 참조 시 `undefined`, `let/const`는 **TDZ**로 인해 `ReferenceError`가 발생한다.

<br />

## 4) 값의 할당

자바스크립트 엔진은 변수 선언과 값의 할당을 하나의 문으로 작성해도 내부적으로는 **두 개의 과정**으로 나누어 실행한다.

- **변수 선언** : 소스코드 평가 과정에서 실행 (런타임 이전)
- **값의 할당** : 런타임(코드 실행 시점)에 실행

```js
var x = 10;
// 내부 동작
var x; // 선언 (평가 단계)
x = 10; // 할당 (런타임)
```

## 5) 값의 재할당

**재할당**은 이미 값이 저장된 변수에 새로운 값을 다시 할당하는 것을 말한다.

- `var` 변수는 선언과 동시에 `undefined`로 초기화되므로, 엄밀히 말하면 최초 값 할당도 사실상 **재할당**이다.
- 변수에 저장된 값은 언제든 재할당으로 변경할 수 있다.
- 만약 재할당이 불가능하다면 그것은 **변수(variable)** 가 아니라 **상수(constant)** 다.

```js
let y = 10;
y = 20; // 재할당 가능

const z = 30;
z = 40; // TypeError: Assignment to constant variable
```

> `let`은 재할당 가능하지만, `const`는 재할당이 불가능하다.

재할당이 일어나면 변수는 이전 값이 아닌 새로운 값을 가리키게 된다.  
이때 **이전 값이 저장되어 있던 메모리 공간에 새 값을 저장**하는 것이 아니라,  
**새로운 메모리 공간을 확보하여 새 값을 저장하고, 변수 식별자가 그 공간을 바라보도록 변경**하는 것이다.

이 과정에서 이전 값은 이제 어떤 식별자와도 연결되지 않게 되며, 이 상태를 **가비지(garbage)** 라고 한다.
자바스크립트 엔진의 **가비지 콜렉터(GC)** 는 더 이상 사용되지 않는 메모리를 자동으로 해제하여 메모리 누수를 방지한다.
다만, **가비지 콜렉터가 언제 동작해 메모리를 해제할지는 예측할 수 없다.**

> **가비지(garbage)**
> 더 이상 어떤 식별자도 참조하지 않아 필요하지 않게 된 메모리 상태

> **가비지 콜렉터**
> 애플리케이션이 할당한 메모리 공간을 주기적으로 검사해, 더 이상 사용되지 않는 메모리를 해제하는 기능  
> (개발자가 명시적으로 해제 불가능)

> **매니지드 언어**
> 메모리 관리(할당/해제)를 언어 차원에서 자동으로 처리하는 언어
> 자바스크립트, 자바, C# 등은 매니지드 언어에 해당하며, 메모리 해제는 가비지 콜렉터가 수행한다.

따라서 자바스크립트 개발자는 메모리 해제를 직접 관리할 필요가 없다.
