# 비동기 프로그래밍

## 1) 동기 처리와 비동기 처리

### 1. 싱글 스레드 방식 (single thread)

자바스크립트 엔진은 **단 하나의 실행 컨텍스트 스택**만 갖기 때문에  
<u>**한 번에 하나의 태스크만 실행**</u>할 수 있다.  
즉, 동시에 2개 이상의 함수를 실행할 수 없다.

- 함수 실행 과정

  1. 함수 호출
  2. `함수 실행 컨텍스트` 생성
  3. `실행 컨텍스트 스택`에 push
  4. 함수 코드 실행
  5. 함수 종료 시 `실행 컨텍스트 스택`에서 pop

- 함수가 호출 순서대로 순차적으로 실행되는 이유
  - 호출 순서대로 `함수 실행 컨텍스트`가 `실행 컨텍스트 스택`에 push 되기 때문임

이 과정 때문에 '실행 중인 실행 컨텍스트(스택의 최상위)'를 제외한 나머지는 실행을 기다려야 한다. (대기 중인 태스크)

따라서 처리 시간이 오래 걸리는 태스크를 실행할 경우 **블로킹(Blocking, 작업 중단)** 문제가 발생한다.

#### 2. 동기 처리 (Synchronous)

현재 실행 중인 태스크가 끝날 때까지 다음 태스크는 대기한다

- 장점 : 실행 순서가 보장됨
- 단점 : 앞선 태스크가 끝날 때까지 이후 태스크들이 블로킹(작업 중단)됨

```js
function sleep(func, delay) {
  const until = Date.now() + delay;
  while (Date.now() < until); // delay 동안 블로킹
  func();
}

function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

sleep(foo, 3000); // 3초 블로킹
bar(); // foo → bar 순서로 실행
```

#### 3. 비동기 처리 (Asynchronous)

현재 실행 중인 태스크가 끝나지 않아도 **다음 태스크를 곧바로 실행**한다.

- 장점 : 블로킹(작업 중단)이 없음 → 전체 흐름이 멈추지 않음
- 단점 : 실행 순서 보장 어려움

```js
function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

setTimeout(foo, 3000); // 비동기 등록
bar(); // bar → (3초 후) foo
```

- 대표적인 비동기 API

  - 타이머 함수 `setTimeout`와 `setInterval`, `HTTP 요청(Ajax/fetch)`, 이벤트 핸들러 등

- **비동기 처리를 위한 콜백 패턴**
  > 비동기 처리를 수행하는 비동기 함수는 전통적으로 **콜백 패턴**을 사용한다.
  - 콜백 헬을 발생 시켜 가독성 X
  - 에러 예외처리 어려움
  - 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있음

### 2) 이벤트 루프와 태스크 큐

그럼 자바스크립트가 **싱글 스레드**인데도 어떻게 비동기 처리가 가능할까?
정답은 **이벤트 루프(Event Loop)** 덕분이다.

#### 1. 자바스크립트 엔진

- **호출 스택(Call Stack)** : 실행 컨텍스트가 push/pop 되는 스택 구조 (=실행 컨텍스트 스택)

- **힙(Heap)** : 객체가 저장되는 메모리 공간 (동적 할당)

➡️ 자바스크립트 엔진은 오직 **소스코드 평가와 실행**만 담당한다.  
 비동기 처리는 **런타임 환경(브라우저 / Node.js)** 이 맡는다.

---

#### 2. 런타임 환경

- **Web API (브라우저) / Node API (Node.js)** : `setTimeout`, DOM 이벤트, Ajax 등 비동기 작업 처리

- **태스크 큐(Task Queue, Callback Queue)** : 비동기 함수의 콜백 함수 / 이벤트 핸들러가 임시 보관되는 영역

- **이벤트 루프(Event Loop)** : 콜 스택이 비었는지 확인하고, 태스크 큐에 대기 중인 함수를 콜 스택으로 이동시킴

---

#### 3. 단계별 실행 흐름

```js
function foo() {
  console.log("foo");
}
function bar() {
  console.log("bar");
}

setTimeout(foo, 0); // 0초(실제는 4ms) 후에 foo 함수가 호출된다.
bar();
```

##### 1. 전역 코드 평가

- 전역 실행 컨텍스트 생성 → **콜 스택 push**
- 함수 `foo`, `bar` 정의됨

---

##### 2. `setTimeout(foo, 0)` 실행

- `setTimeout` 실행 컨텍스트 생성 → **콜 스택 push**
- 런타임(Web API)에 **타이머 등록 (0ms 뒤 `foo` 실행 예약) → 타이머 즉시 카운트 시작**
- `setTimeout` 실행 종료 → **콜 스택 pop**

> 여기서부터 타이머는 JS 스레드와 **독립적으로** 런타임에서 동작 중

---

##### 3. `bar()` 실행

- `bar` 실행 컨텍스트 생성 → **콜 스택 push**
- `console.log("bar")` 출력
- 실행 종료 → **콜 스택 pop**

---

##### 4. 전역 실행 종료

- 전역 실행 컨텍스트 pop
- 이제 **콜 스택이 완전히 비게 됨**

---

##### 5. Web API에서 타이머 만료

- 런타임에서 타이머 만료 감지
- 콜백 `foo`를 **태스크 큐(Task Queue)** 에 enqueue

---

##### 6. 이벤트 루프 동작

- 이벤트 루프가 **콜 스택이 비었는지 확인**
- 비어 있으므로, 태스크 큐에서 `foo`를 꺼내 **콜 스택 push**

---

##### 7. `foo()` 실행

- 실행 컨텍스트 생성 → **콜 스택 push**
- `console.log("foo")` 출력
- 실행 종료 → **콜 스택 pop**

---

```yaml
시간 ───────────────────────────────────────────────────────────────▶

레일 A: JS 콜 스택   | (전역 평가) ─ setTimeout 실행 → bar() 실행 → (비움) → foo 실행
                      |                       ▲                         ▲
                      |                       |                         |
레일 B: 런타임(WebAPI)|           타이머 시작 ─┴──────────(카운트)──────┴→ 태스크 큐에 foo 등록

레일 C: 태스크 큐     |                          [ foo 대기 ] ──┐
                                                       이벤트 루프 ──┘ (스택 비면 foo 실행)

```

➡️ `자바스크립트 엔진`은 **싱글 스레드**로 동작한다.
하지만 `브라우저`와 `Node.js 런타임`은 내부적으로 **멀티 스레드 환경**을 갖고 있어,  
타이머, 이벤트 감지, 네트워크 요청 같은 작업을 **백그라운드에서 병렬로 처리**한다.

따라서 JS 코드 자체는 한 번에 하나씩 실행되지만, <u>런타임이 여러 작업을 동시에 진행하고, 완료 시점에 해당 콜백을 큐에 등록하기 때문에</u>
**싱글 스레드임에도 여러 비동기 작업이 동시에 처리되는 것처럼 보인다.**

---

- **자바스크립트 엔진**: `실행자` → 콜 스택에서 코드를 **하나씩 순차적으로 실행**

- **런타임**: `작업자` → 타이머·네트워크·이벤트를 **백그라운드에서 처리**하고, **콜백만 큐에 넣어줌**

- **이벤트 루프**: `조율자` → 콜 스택과 큐를 **중재**하며, 스택이 비면 큐에서 콜백을 꺼내 실행하도록 연결
