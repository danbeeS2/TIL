# 스코프(Scope)

## 1) 스코프 개념

스코프는 **`식별자의 유효 범위`** 를 의미한다.  
변수, 함수, 클래스 등 모든 식별자는 **선언된 위치에 따라** 참조 가능한 범위가 결정된다.

### 스코프의 역할

1. **식별자 결정**
   - 같은 이름의 변수가 여러 개 존재할 때, 자바스크립트 엔진은 **스코프 규칙**에 따라 어떤 변수를 참조할지 결정한다.
2. **실행 코드의 문맥 고려**
   - 자바스크립트 엔진은 코드를 실행할 때 `렉시컬 환경`을 기반으로 식별자를 검색한다.
     > `렉시컬 환경` : 코드가 어디에서 실행되며, 어떤 코드에 둘러싸여 있는지
   - 즉, 코드가 **어디에서 선언되고 실행되었는지(문맥)**에 따라 결과가 달라질 수 있다.
3. **네임스페이스 제공**
   - 스코프는 변수 이름 충돌을 방지한다.
   - 서로 다른 스코프라면 **동일한 이름의 식별자**를 안전하게 사용할 수 있다.

> 스코프는 **자바스크립트 엔진이 식별자를 검색하고 관리하는 규칙**이자, 코드 실행 시 **변수 충돌을 방지하는 네임스페이스**이다.

## 2) 스코프의 종류

**전역 스코프 (Global Scope)**

- 코드 어디에서나 참조할 수 있는 범위
- 전역에 선언된 변수는 전역 객체(window / global)의 프로퍼티가 됨

**지역 스코프 (Local Scope)**

- 함수나 블록 내부에서 선언된 변수는 해당 지역에서만 유효
- 외부에서는 접근할 수 없음
- 함수는 중첩될 수 있으므로 함수의 지역 스코프도 중첩될 수 있음

## 3) 스코프 체인

- 스코프는 **계층적 구조**를 가진다.
- 가장 바깥쪽에는 **전역 스코프**가 있으며, 그 안에 **지역 스코프들이 중첩**된다.
- 변수를 참조할 때 자바스크립트 엔진은 **현재 스코프 → 상위 스코프 → … → 전역 스코프** 순으로 탐색한다.
- 이 연결 구조를 **`스코프 체인`** 이라고 한다.

### 렉시컬 환경과의 관계

자바스크립트 엔진은 코드를 실행하기 전, **렉시컬 환경(Lexical Environment)** 이라는 자료구조를 생성한다.

- 변수 선언 시: 렉시컬 환경에 **식별자(key)** 가 등록됨
- 값 할당 시: 해당 식별자의 value가 갱신됨


- 스코프 체인은 사실상 **실행 컨텍스트의 렉시컬 환경을 단방향으로 연결한 것**이다.
  ```js
  function outer() {
    let x = 10; // outer의 렉시컬 환경에 { x: 10 } 저장

    function inner() {
      let y = 20; // inner의 렉시컬 환경에 { y: 20 } 저장
      console.log(x + y); // inner 렉시컬 환경에 x 없음 → outer로 올라가서 찾음
    }

    inner();
  }

  outer();
  ```



> - **스코프 = 규칙** (변수를 어떻게 찾을지)
> - **렉시컬 환경 = 실제 저장소** (그 규칙을 구현하는 데이터 구조)
> - 자바스크립트 엔진은 변수를 단순히 메모리에 두는 게 아니라, **렉시컬 환경이라는 체계적 구조 안에 기록**해둠
> - 이 구조 덕분에 스코프 체인이 동작하고, 클로저도 가능해짐

## 4) 함수 레벨 스코프 vs 블록 레벨 스코프

### 함수 레벨 스코프(Function Scope)

- 함수 내부에서 선언된 변수는 함수 외부에서 참조할 수 없음
- `var` 키워드가 대표적
- `var`는 **오직 함수 단위**로만 스코프가 생성됨 → `if`, `for`, `{}` 같은 블록은 무시됨
- 이러한 특성 때문에 var 키워드로 선언된 변수는 의도치 않게 전역 변수가 될 수 있음

  ```javascript
  function A() {
    var a = 3;
  }

  if (true) {
    var b = 5;
  }

  A();

  console.log(a); // ReferenceError: a is not defined
  console.log(b); // 5 (블록 무시, 전역 변수처럼 동작)
  ```

### 블록 레벨 스코프(Block Scope)

- **모든 코드 블록(함수, if, for, while, try/catch 등)** 에서 스코프가 생성됨
- ES6에서 도입된 `let`, `const` 키워드가 블록 레벨 스코프를 따름
- `{}` 블록 안에서 선언되면 그 블록 안에서만 유효하고, 바깥에서는 접근 불가능
- 모든 블록에서 독립적인 지역 변수가 만들어짐(안전한 지역 변수)

  ```javascript
  function A() {
    let a = 4;
  }
  if (true) {
    let b = 5;
  }
  A();

  console.log(a); // ReferenceError: a is not defined
  console.log(b); // ReferenceError: b is not defined
  ```

## 5) 렉시컬 스코프

함수의 **상위 스코프**를 결정하는 방법은 두 가지가 있다.

1. `함수를 어디서 호출`했는지에 따라 함수의 상위 스코프가 결정된다. ⇒ 동적 스코프
2. `함수를 어디서 정의`했는지에 따라 함수의 상위 스코프가 결정된다. ⇒ 렉시컬 스코프 (=정적 스코프) 


### 자바스크립트는 `렉시컬 스코프`
- 대부분의 프로그래밍 언어와 마찬가지로, 자바스크립트도 **렉시컬 스코프**를 따른다.
- 함수가 호출되는 위치와 상관없이 **정의된 위치의 스코프**를 기억한다.
- 이때 참조하는 저장소가 바로 **렉시컬 환경**이다.
- **함수의 상위 스코프는 언젠나 자신이 정의된 스코프이다.**

```javascript
const b = 5;
function outer() {
  const b = 10;
  // 선언된 위치 - 렉시컬 스코프 ⇒ 10
  return function inner() {
    console.log(b);
  };
}

// 호출한 위치 - 동적 스코프 ⇒ 5
const inner = outer();
inner(); // 10
```

만약 동적 스코프 였다면, outer가 리턴한 함수는 전역객체의 b(b = 5)를 참조했을 것이다.  
하지만 자바스크립트는 렉시컬 스코프를 따르므로 `inner`함수는 언제 어디서 실행되더라도 항상 `outer`의 스코프(b = 10)를 참조한다.

## 정리

스코프는 **변수의 유효 범위**를, 스코프 체인은 그 범위들을 **연결한 탐색 경로**를 의미한다.  
그리고 이 연결은 실행 컨텍스트 내부의 **렉시컬 환경** 구조를 통해 구현된다.


자바스크립트에서 함수의 상위 스코프는 **호출 위치가 아니라, 정의된 위치(렉시컬 스코프)** 기준으로 결정된다.