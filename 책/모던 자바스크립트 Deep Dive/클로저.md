# 클로저 (closure)

## 1) 클로저 정의

클로저는 **"함수와 그 함수가 선언된 렉시컬 환경(Lexical Environment)과의 조합"** 이다.
즉, 함수가 **외부 함수의 변수**에 접근할 수 있는 구조를 말한다.

- 자바스크립트에서 함수는 **일급 객체**이므로

  1. 변수에 할당 가능
  2. 인자로 전달 가능
  3. 반환값으로 사용 가능  
     → 이런 특성 때문에 클로저를 활용할 수 있다.

  ***

  > ➕ 추가 문법적 특징
  >
  > - 익명 함수(Anonymous Function) 작성 가능
  > - 함수 리터럴을 즉시 실행(IIFE) 가능

<br />

`함수가 선언된 렉시컬 환경`이 핵심 키워드다.

- **렉시컬 스코프**: 함수는 "선언된 위치" 기준으로 상위 스코프를 기억한다.

```js
const x = 1;

function outerFn() {
  const x = 3;
  function innerFn() {
    console.log(x);
  }
  innerFn();
}

outerFn(); // 3 ← 호출 위치와 상관없이 "정의된 위치" 기준으로 스코프 결정
```

- `innerFn`은 `outerFn` 내부에서 선언 → `innerFn`의 상위 스코프는 외부 함수인 `outerFn`의 스코프이다.
- `innerFn`이 `outerFn`의 변수 `x`를 접근할 수 O

```js
const x = 1;
function outerFn() {
  const x = 3;
  innerFn();
}
function innerFn() {
  console.log(x);
}
outerFn(); // 1
```

- `innerFn`은 전역 스코프에서 선언 → `innerFn`의 상위 스코프는 전역 스코프이다.
- `innerFn`이 `outerFn`의 변수 `x`를 접근할 수 X

## 2) 렉시컬 스코프

#### 1. 렉시컬 스코프란?

- 함수의 상위 스코프는 **“호출 위치”가 아니라 “정의된 위치”** 에 의해 결정된다.
- 그래서 **렉시컬(정적) 스코프**라고 부른다.

---

#### 2. 스코프의 실체 = 렉시컬 환경

- **렉시컬 환경(Lexical Environment)** = 실행 컨텍스트에서 변수/함수 선언을 저장하는 객체 같은 구조
- 그 안에는 2가지 중요한 정보가 있음

  1. **환경 레코드(Environment Record)** → 현재 스코프에 선언된 변수/함수들 저장소
  2. **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)** → 상위 스코프를 가리키는 “링크”

---

#### 3. 상위 스코프가 정해지는 시점

- **함수가 정의될 때**, 자바스크립트 엔진은 함수 객체 내부에 **[[Environment]] 슬롯**을 만들고, 여기에 **"상위 스코프에 대한 참조"** 를 저장한다.
- 즉, **함수 정의 시점의 위치**가 상위 스코프를 결정한다.

**`상위 스코프를 결정한다`**  
= 함수가 실행될 때, 그 함수가 **어떤 스코프 체인에 연결될지를 정한다**는 뜻

> `스코프 체인` : 내부 스코프에서 식별자를 찾지 못하면 외부 스코프를 차례대로 탐색하는 연결 리스트 구조
>
> > 자신 → 없으면 상위 → 없으면 더 상위 ... 순서로 찾음 ⇒ 최종적으로 전역 스코프

---

**렉시컬 스코프**는 “함수가 정의된 위치에 따라 상위 스코프가 결정되는 것”이며,
이때 자바스크립트 엔진은 함수에 상위 스코프 참조(링크)를 저장해 두고, 변수를 찾을 땐 스코프 체인을 따라 위로 거슬러 올라간다.

따라서 상위 스코프를 결정한다는 것은 **"렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값을 결정한다"** 는 것이다.

렉시컬 환경의 "**외부 렉시컬 환경에 대한 참조"에 저장할 참조값**, 즉 `상위 스코프에 대한 참조`는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.

- **렉시컬 환경(Lexical Environment)** = 실행 컨텍스트에서 변수/함수 선언을 기록하는 객체 같은 구조
- 그 안에는 2가지 중요한 정보가 있음

  1. **환경 레코드(Environment Record)** → 현재 스코프에 선언된 변수/함수들 저장소
  2. **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)** → 상위 스코프를 가리키는 “링크”

> “상위 스코프를 결정한다”  
> = 함수가 실행될 때, 그 함수가 **어떤 스코프 체인에 연결될지를 정한다**는 뜻

→ 실제로는 함수 객체 안에 **[[Environment]]** 라는 숨겨진 슬롯이 만들어지는데, 여기에 **“외부 렉시컬 환경에 대한 참조”** 가 저장된다.

---

- 함수가 만들어질 때, 자바스크립트 엔진은 그 함수 안에 **“상위 스코프를 가리키는 참조(링크)”**를 저장한다.
- 이 참조는 **“함수가 어디서 정의되었는가”**로 결정된다.
- 그래서 이걸 **“렉시컬 환경의 외부 렉시컬 환경에 대한 참조를 저장한다”**라고 표현하는 것.

<br />

## 3) 함수 객체의 내부 슬롯 [[Environment]]

함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 **상위 스코프의 렉시컬 환경에 대한 참조**를 저장한다.

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

// bar는 전역 렉시컬 환경을 [[Environment]]에 저장한다.
function bar() {
  console.log(x);
}
bar(); // 1
foo(); // 1
```

1. bar는 전역 함수이고, bar 함수가 평가될 때는 전역 스코프에서 평가가된다.
2. 그렇기 때문에 [[Environment]]에는 전역 스코프의 렉시컬 환경에 대한 참조가 저장된다.
3. 따라서 bar 함수는 전역 스코프의 x를 항상 참조한다.

<br />

## 4) 클로저와 렉시컬 환경

#### 1. 기본 원리

```js
const x = 1;
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

outer()(); // 10
```

1. **정의 시점**

   - `outer` 함수가 정의될 때:
     `outer.[[Environment]] = 전역 렉시컬 환경`
   - `inner` 함수가 정의될 때:
     `inner.[[Environment]] = outer의 렉시컬 환경` (상위 스코프 참조 저장)

---

2. **outer 호출 시**

   - 새로운 실행 컨텍스트 + **outer 전용 렉시컬 환경** 생성
     (여기에 `x = 10`, `inner` 저장됨)
   - `outer`는 `inner` 함수를 반환

---

3. **outer 실행 종료**

   - `outer` 함수의 생명 주기 종료
   - `outer` 실행 컨텍스트는 스택에서 제거(pop)됨
   - 하지만 `inner.[[Environment]]`가 **outer의 렉시컬 환경을 참조**하고 있기 때문에  
     → `outer`의 렉시컬 환경은 GC(가비지 콜렉션) 대상이 되지 않음

---

4. **inner 호출 시**

   - `inner` 실행 컨텍스트 + **inner 전용 렉시컬 환경** 생성 (자체 변수 없음)
   - 식별자 `x` 탐색 순서:

     - `inner` → 없음
     - 상위 스코프(=outer의 렉시컬 환경) → `x = 10` 발견

---

- `outer` 실행 컨텍스트는 제거되었으나, 여전히 `inner`의 [[Environment]]에서 **`outer`의 렉시컬 환경**을 참조하고 있음 → 가비지 컬렉터의 제거 대상이 되지 않음
- 이 구조 덕분에 `inner()`는 `outer`의 변수(`x=10`)를 계속 사용할 수 있고, 이게 바로 **클로저**

#### 2. 클로저

- 자바스크립트의 모든 함수는 상위 스코프를 기억하기 때문에 이론적으로는 모두 클로저다.
- 하지만 일반적으로 `클로저`가 되기 위해서는 두 가지 조건을 충족해야 한다.
  1. **내부 함수가 외부 함수보다 생명 주기가 길어야 한다.** (ex. 반환된 함수, 콜백 등)
  2. **내부 함수가 상위 스코프의 식별자를 참조 해야한다.**

#### 3. 자유 변수와 메모리

> **자유 변수 (Free Variable)**: 클로저에 의해 참조되는 상위 스코프의 변수

- “클로저(closure)”라는 이름도 **“함수가 자유 변수에 대해 닫혀있다”** 는 의미에서 유래
- 자바스크립트 엔진은 더 이상 참조되지 않는 변수만 가비지 콜렉션(GC)의 대상으로 삼기 때문에
  → **클로저 자체가 메모리 누수를 일으키지는 않는다**

<br />

## 5) 클로저 활용

클로저는 상태를 안전하게 변경하고 유지하기 위해 사용된다.  
다시 말해 상태가 의도치 않게 변경되지 않도록 **상태를 안전하게 은닉**하고, **특정 함수에게만 상태 변경을 허용**하기 위해 사용된다.

```js
function createBankAccount() {
  let balance = 0; // 외부에서 접근 불가

  return {
    deposit(amount) {
      balance += amount;
      return balance;
    },

    withdraw(amount) {
      if (balance < amount) {
        console.log("잔액이 부족합니다.");
        return;
      }
      balance -= amount;
      return balance;
    },

    getBalance() {
      return balance;
    },
  };
}
const account = createBankAccount();
account.deposit(100);
account.withdraw(50);
console.log(account.getBalance()); // 50
console.log(account.balance); // undefined (직접 접근 불가)
```

## 6) 캡슐화와 정보 은닉

- **캡슐화(Encapsulation)**: 객체의 상태(프로퍼티)와 동작(메서드)을 하나로 묶는 것
- **정보 은닉(Information Hiding)**: 외부에서 특정 데이터(프로퍼티)에 직접 접근하지 못하게 하고, 오직 메서드를 통해서만 접근 가능하게 만드는 것
  - 안정성(정보 보호) ↑, 결합도(객체 간의 상호 의존성) ↓

---

- **JS 옛날 방식**: `private`, `protected` 같은 키워드가 없었기 때문에 **클로저**로 정보 은닉을 흉내냈음
- **JS 최신 방식 (ES2020\~)**:`class #private` 필드 도입 → 언어 차원에서 은닉 지원

---

### 정보 은닉 방식

#### 1. 생성자 함수 안에 메서드 정의

```js
function User(id, password) {
  this.id = id; // this → 인스턴스에 직접 저장
  let _password = password; // private 변수 (this에 없음)

  // 클로저
  // checkPassword 함수가 User 실행 시점의 렉시컬 환경을 기억(클로저)
  // 렉시컬 환경 안에 _password가 있으므로, 외부에서 checkPassword를 호출해도 계속 접근 가능
  this.checkPassword = function (pw) {
    return _password === pw;
  };
}

const user1 = new User("danbi", "1234");
user1.checkPassword("1234"); // true

console.log(user1.id); // danbi
console.log(user1._password); // undefined (외부에서 직접 접근 불가)
```

- 장점: `_password`를 은닉할 수 있음 (외부에서 직접 접근 불가)
- 단점: **인스턴스를 만들 때마다** 새로운 함수 객체(`checkPassword`)가 생성됨 → 인스턴스가 많아지면 **메모리 낭비**

---

#### 2. 프로토타입 메서드로 옮기기

```js
function User(id, password) {
  this.id = id;
  let _password = password;
}

User.prototype.checkPassword = function (pw) {
  return _password === pw; //  에러
};
```

- 프로토타입 메서드는 **인스턴스가 공유**해서 효율적
- 하지만 이 경우 `checkPassword`가 `_password`에 접근 못함  
  (프로토타입 메서드는 생성자 함수 실행 시 만들어진 렉시컬 환경에 접근 불가)

➡️ 그래서 클로저 + 프로토타입을 동시에 만족시키기 어려움

---

#### 3. IIFE(즉시 실행 함수)로 감싸기

```js
const User = (function () {
  let _password;
  // 해당 스코프에 단 하나만 존재
  // 인스턴스마다 새로 만들어지는 게 아님
  // 모든 User 인스턴스가 같은 _password 변수를 공유

  function User(id, password) {
    this.id = id;
    _password = password; // 모든 인스턴스가 이 변수 공유
  }

  // 클로저
  // 하지만 _password은 모든 인스턴스가 공유하고 있는 변수라서
  // 아무리 새로운 인스턴스를 만들어도 덮여씌워짐
  User.prototype.checkPassword = function (pw) {
    return _password === pw;
  };
  return User;
})();

const user1 = new User("danbi", "0000");
const user2 = new User("danbi", "1234");

user1.checkPassword("0000"); // false
user1.checkPassword("1234"); // true
```

- `checkPassword`는 클로저라 `_password`에 접근 가능
- 하지만 문제: `_password`가 **모든 인스턴스에서 공유됨**  
  → user1, user2가 다른 비밀번호를 갖지 못하고, 마지막에 세팅된 값만 남음

➡️ 이것이 IIFE + 프로토타입 클로저 기반 은닉 방식의 한계

---

#### 그래서 나온 해결책 — `class #private`

```js
class User {
  #password; // private 필드
  // 렉시컬 환경에 저장되는 게 아니라, 각 인스턴스 내부의 "Private 슬롯"에 저장됨
  // 이 슬롯은 해당 클래스 정의 블록 (메서드/constructor) 내부에서만 접근 가능

  constructor(id, password) {
    this.id = id; // public  → 인스턴스 프로퍼티에 저장
    this.#password = password; // private → 인스턴스의 private 슬롯에 저장
  }

  checkPassword(password) {
    return this.#password === password; // 같은 private 슬롯 조회
  }

  changePassword(oldPw, newPw) {
    if (this.#password === oldPw) {
      this.#password = newPw; // 같은 private 슬롯 수정
      return true;
    }
    return false;
  }
}

const user1 = new User("danbi", "1234");

console.log(user1.id); // "danbi" (public)
console.log(user1.checkPassword("1234")); // true
console.log(user1.changePassword("1234", "5678")); // true
console.log(user1.checkPassword("5678")); // true

console.log(user1.#password); // SyntaxError (외부 접근 불가)
```

- `id`는 public → 외부 접근 가능
- `#password`는 private → **인스턴스마다 독립적**이고 외부 접근 불가 (**SyntaxError** 발생)
- `checkPassword`, `changePassword` 같은 메서드만을 통해서만 비밀번호 조작 가능
- 메서드는 프로토타입에 공유되므로 메모리 효율도 좋음

---

- **옛날 JS**: `private` 키워드가 없어서 클로저로 은닉 흉내 → 하지만 인스턴스마다 메서드 중복 생성 or 모든 인스턴스가 같은 변수를 공유하는 문제가 있었음
- **지금 JS (ES2020\~)**: `class #private` 필드가 도입되어, 진짜 언어 차원의 은닉 가능 → 클로저보다 명확하고 안전
  > 그렇기 때문에 **정보 은닉**만을 위한 목적이라면. 클로저보다 `class #private` 쓰는 게 일반적이다.

<br />

## 7) 자주 발생하는 실수

```js
var fns = [];

for (var i = 0; i < 3; i++) {
  fns[i] = function () {
    return i;
  };
}

for (var j = 0; j < 3; j++) {
  console.log(fns[j]());
}
```

위의 결과는 항상 `3`이 나온다.  
for 문의 변수 선언문에서 `var 키워드`로 선언한 `i` 변수는 블록 레벨 스코프가 아닌 **함수 레벨 스코프**를 갖기 때문이다. 따라서 `i` 변수는 **전역 변수**이다.

1. **첫 번째 for문**

   - `i=0` → `fns[0] = function() { return i }`
   - `i=1` → `fns[1] = function() { return i }`
   - `i=2` → `fns[2] = function() { return i }`

   ➡️ 루프가 끝난 뒤 `i=3`이 됨

2. **두 번째 for문**

   - `fns[0]()` 호출 → `function() { return i }` 실행 → **전역 i(=3)** 반환
   - `fns[1]()` → 역시 `i`를 보고, 전역 `i=3` 반환
   - `fns[2]()` → 역시 전역 `i=3` 반환

   ➡️ 그래서 결과는 `3, 3, 3`

---

#### 2. 블록 레벨 스코프 `let` 사용

```js
var fns = [];

for (let i = 0; i < 3; i++) {
  fns[i] = function () {
    return i;
  };
}

for (var j = 0; j < 3; j++) {
  console.log(fns[j]()); // 0, 1, 2
}
```

- `let`은 블록 스코프이기 때문에 매 반복마다 **새로운 i 변수가 생성**됨
- 각 함수는 그 “자기만의 i”를 클로저로 기억 → `0,1,2` 출력

---

#### 3. IIFE + 클로저 사용

```js
var fns = [];

for (var i = 0; i < 3; i++) {
  fns[i] = (function (id) {
    // 클로저
    return function () {
      return id;
    };
  })(i); // 즉시 실행 함수
}

for (var j = 0; j < 3; j++) {
  console.log(fns[j]()); // 0,1,2
}
```

- 매 반복마다 `i`를 `id`라는 새 변수에 캡쳐 → 함수는 그 값을 클로저로 기억

1. **첫 번째 for문**

   - `i=0` → `(function(id){ ... })(0)` 실행 → `id=0`인 렉시컬 환경 생성 → `fns[0] = function(){ return id }`
   - `i=1` → `(function(id){ ... })(1)` 실행 → `id=1`인 렉시컬 환경 생성 → `fns[1] = function(){ return id }`
   - `i=2` → `(function(id){ ... })(2)` 실행 → `id=2`인 렉시컬 환경 생성 → `fns[2] = function(){ return id }`

   ➡️ 루프 종료 후 `i=3`이 되지만, 각 함수는 자기만의 `id`(0,1,2)를 클로저로 기억

2. **두 번째 for문**

- IIFE로 `id`라는 새로운 매개변수를 만들어 각 반복마다 **독립 스코프** 생성
  - `fns[0]()` → `function() { return id }` 실행 → `0` 반환
  - `fns[1]()` → `function() { return id }` 실행 → `1` 반환
  - `fns[2]()` → `function() { return id }` 실행 → `2` 반환

➡️ 그래서 결과는 `0, 1, 2`

> **즉시 실행 함수(IIFE)**: 실행될 때마다 새로운 실행 컨텍스트 + 렉시컬 환경을 만들어서 **독립된 스코프를 형성**
