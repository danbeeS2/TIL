# 클로저 (closure)

## 1) 클로저 정의

클로저는 **"함수와 그 함수가 선언된 렉시컬 환경(Lexical Environment)과의 조합"** 이다.
즉, 함수가 **외부 함수의 변수**에 접근할 수 있는 구조를 말한다.

- 자바스크립트에서 함수는 **일급 객체**이므로

  1. 변수에 할당 가능
  2. 인자로 전달 가능
  3. 반환값으로 사용 가능  
     → 이런 특성 때문에 클로저를 활용할 수 있다.

  ***

  > ➕ 추가 문법적 특징
  >
  > - 익명 함수(Anonymous Function) 작성 가능
  > - 함수 리터럴을 즉시 실행(IIFE) 가능

<br />

`함수가 선언된 렉시컬 환경`이 핵심 키워드다.

- **렉시컬 스코프**: 함수는 "선언된 위치" 기준으로 상위 스코프를 기억한다.

```js
const x = 1;

function outerFn() {
  const x = 3;
  function innerFn() {
    console.log(x);
  }
  innerFn();
}

outerFn(); // 3 ← 호출 위치와 상관없이 "정의된 위치" 기준으로 스코프 결정
```

- `innerFn`은 `outerFn` 내부에서 선언 → `innerFn`의 상위 스코프는 외부 함수인 `outerFn`의 스코프이다.
- `innerFn`이 `outerFn`의 변수 `x`를 접근할 수 O

```js
const x = 1;
function outerFn() {
  const x = 3;
  innerFn();
}
function innerFn() {
  console.log(x);
}
outerFn(); // 1
```

- `innerFn`은 전역 스코프에서 선언 → `innerFn`의 상위 스코프는 전역 스코프이다.
- `innerFn`이 `outerFn`의 변수 `x`를 접근할 수 X

## 2) 렉시컬 스코프

#### 1. 렉시컬 스코프란?

- 함수의 상위 스코프는 **“호출 위치”가 아니라 “정의된 위치”** 에 의해 결정된다.
- 그래서 **렉시컬(정적) 스코프**라고 부른다.

---

#### 2. 스코프의 실체 = 렉시컬 환경

- **렉시컬 환경(Lexical Environment)** = 실행 컨텍스트에서 변수/함수 선언을 저장하는 객체 같은 구조
- 그 안에는 2가지 중요한 정보가 있음

  1. **환경 레코드(Environment Record)** → 현재 스코프에 선언된 변수/함수들 저장소
  2. **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)** → 상위 스코프를 가리키는 “링크”

---

#### 3. 상위 스코프가 정해지는 시점

- **함수가 정의될 때**, 자바스크립트 엔진은 함수 객체 내부에 **[[Environment]] 슬롯**을 만들고, 여기에 **"상위 스코프에 대한 참조"** 를 저장한다.
- 즉, **함수 정의 시점의 위치**가 상위 스코프를 결정한다.

**`상위 스코프를 결정한다`**  
= 함수가 실행될 때, 그 함수가 **어떤 스코프 체인에 연결될지를 정한다**는 뜻

> `스코프 체인` : 내부 스코프에서 식별자를 찾지 못하면 외부 스코프를 차례대로 탐색하는 연결 리스트 구조
>
> > 자신 → 없으면 상위 → 없으면 더 상위 ... 순서로 찾음 ⇒ 최종적으로 전역 스코프

---

**렉시컬 스코프**는 “함수가 정의된 위치에 따라 상위 스코프가 결정되는 것”이며,
이때 자바스크립트 엔진은 함수에 상위 스코프 참조(링크)를 저장해 두고, 변수를 찾을 땐 스코프 체인을 따라 위로 거슬러 올라간다.

따라서 상위 스코프를 결정한다는 것은 **"렉시컬 환경의 '외부 렉시컬 환경에 대한 참조'에 저장할 참조값을 결정한다"** 는 것이다.

렉시컬 환경의 "**외부 렉시컬 환경에 대한 참조"에 저장할 참조값**, 즉 `상위 스코프에 대한 참조`는 함수 정의가 평가되는 시점에 함수가 정의된 환경(위치)에 의해 결정된다.

- **렉시컬 환경(Lexical Environment)** = 실행 컨텍스트에서 변수/함수 선언을 기록하는 객체 같은 구조
- 그 안에는 2가지 중요한 정보가 있음

  1. **환경 레코드(Environment Record)** → 현재 스코프에 선언된 변수/함수들 저장소
  2. **외부 렉시컬 환경에 대한 참조(Outer Lexical Environment Reference)** → 상위 스코프를 가리키는 “링크”

> “상위 스코프를 결정한다”  
> = 함수가 실행될 때, 그 함수가 **어떤 스코프 체인에 연결될지를 정한다**는 뜻

→ 실제로는 함수 객체 안에 **[[Environment]]** 라는 숨겨진 슬롯이 만들어지는데, 여기에 **“외부 렉시컬 환경에 대한 참조”** 가 저장된다.

---

- 함수가 만들어질 때, 자바스크립트 엔진은 그 함수 안에 **“상위 스코프를 가리키는 참조(링크)”**를 저장한다.
- 이 참조는 **“함수가 어디서 정의되었는가”**로 결정된다.
- 그래서 이걸 **“렉시컬 환경의 외부 렉시컬 환경에 대한 참조를 저장한다”**라고 표현하는 것.

<br />

## 3) 함수 객체의 내부 슬롯 [[Environment]]

함수는 자신의 내부 슬롯 [[Environment]]에 자신이 정의된 환경, 즉 **상위 스코프의 렉시컬 환경에 대한 참조**를 저장한다.

```js
const x = 1;

function foo() {
  const x = 10;
  bar();
}

// bar는 전역 렉시컬 환경을 [[Environment]]에 저장한다.
function bar() {
  console.log(x);
}
bar(); // 1
foo(); // 1
```

1. bar는 전역 함수이고, bar 함수가 평가될 때는 전역 스코프에서 평가가된다.
2. 그렇기 때문에 [[Environment]]에는 전역 스코프의 렉시컬 환경에 대한 참조가 저장된다.
3. 따라서 bar 함수는 전역 스코프의 x를 항상 참조한다.

<br />

## 4) 클로저와 렉시컬 환경

#### 1. 기본 원리

```js
const x = 1;
function outer() {
  const x = 10;
  const inner = function () {
    console.log(x);
  };
  return inner;
}

outer()(); // 10
```

1. **정의 시점**

   - `outer` 함수가 정의될 때:
     `outer.[[Environment]] = 전역 렉시컬 환경`
   - `inner` 함수가 정의될 때:
     `inner.[[Environment]] = outer의 렉시컬 환경` (상위 스코프 참조 저장)

---

2. **outer 호출 시**

   - 새로운 실행 컨텍스트 + **outer 전용 렉시컬 환경** 생성
     (여기에 `x = 10`, `inner` 저장됨)
   - `outer`는 `inner` 함수를 반환

---

3. **outer 실행 종료**

   - `outer` 함수의 생명 주기 종료
   - `outer` 실행 컨텍스트는 스택에서 제거(pop)됨
   - 하지만 `inner.[[Environment]]`가 **outer의 렉시컬 환경을 참조**하고 있기 때문에  
     → `outer`의 렉시컬 환경은 GC(가비지 콜렉션) 대상이 되지 않음

---

4. **inner 호출 시**

   - `inner` 실행 컨텍스트 + **inner 전용 렉시컬 환경** 생성 (자체 변수 없음)
   - 식별자 `x` 탐색 순서:

     - `inner` → 없음
     - 상위 스코프(=outer의 렉시컬 환경) → `x = 10` 발견

---

- `outer` 실행 컨텍스트는 제거되었으나, 여전히 `inner`의 [[Environment]]에서 **`outer`의 렉시컬 환경**을 참조하고 있음 → 가비지 컬렉터의 제거 대상이 되지 않음
- 이 구조 덕분에 `inner()`는 `outer`의 변수(`x=10`)를 계속 사용할 수 있고, 이게 바로 **클로저**

#### 2. 클로저

- 자바스크립트의 모든 함수는 상위 스코프를 기억하기 때문에 이론적으로는 모두 클로저다.
- 하지만 일반적으로 `클로저`가 되기 위해서는 두 가지 조건을 충족해야 한다.
  1. **내부 함수가 외부 함수보다 생명 주기가 길어야 한다.** (ex. 반환된 함수, 콜백 등)
  2. **내부 함수가 상위 스코프의 식별자를 참조 해야한다.**

#### 3. 자유 변수와 메모리

> **자유 변수 (Free Variable)**: 클로저에 의해 참조되는 상위 스코프의 변수

- “클로저(closure)”라는 이름도 **“함수가 자유 변수에 대해 닫혀있다”** 는 의미에서 유래
- 자바스크립트 엔진은 더 이상 참조되지 않는 변수만 가비지 콜렉션(GC)의 대상으로 삼기 때문에
  → **클로저 자체가 메모리 누수를 일으키지는 않는다**

<br />
