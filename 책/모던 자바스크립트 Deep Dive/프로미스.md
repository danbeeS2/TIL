# 프로미스 (Promise)

비동기 함수는 **비동기 처리 결과를 함수의 반환값으로 직접 내보낼 수도 없고, 상위 스코프의 변수에 할당할 수도 없다.**

그 이유는 실행 시점이 맞지 않기 때문이다.

- 함수의 **반환(return)** 은 호출 직후 곧바로 일어나야 하지만,
  비동기 처리 결과는 네트워크 응답이나 타이머 만료처럼 **나중에야 준비**된다.
  따라서 비동기 콜백 내부에서 `return`을 해도, 그것은 함수 전체의 반환값이 될 수 없다.

- 상위 스코프 변수에 할당하는 것도 가능은 하지만, 그 할당은 **비동기 작업이 끝난 뒤**에야 이루어진다.
  반면 상위 스코프 변수를 읽는 동기 코드는 이미 먼저 실행되어 버리므로, `undefined`가 나온다.

➡️ 실행 시점 차이로 인해 비동기 함수의 결과는 **즉시 반환**할 수 없으므로, 후속 처리는 함수 내부에서 수행해야 한다.  
이를 위해 전통적으로 `콜백`, 이후 `Promise`, `async/await` 패턴이 사용된다.

## 1) 비동기 처리를 위한 콜백 패턴의 단점

### 1. 콜백 헬

비동기 함수의 결과를 콜백으로 처리하면,  
다음 비동기 작업도 콜백 안에서 호출해야 하므로 **중첩 구조**가 생긴다.

이것이 **`콜백 헬(callback hell)`** 이다.

```js
// 서버에서 사용자 정보 가져오기
getUser(1, (user) => {
  console.log("user:", user);

  // 그 사용자의 게시글 가져오기
  getPosts(user.id, (posts) => {
    console.log("posts:", posts);

    // 그 게시글의 댓글 가져오기
    getComments(posts[0].id, (comments) => {
      console.log("comments:", comments);
    });
  });
});
```

> 쉽게 말해, 비동기 함수의 결과는 **나중에야 준비** 되기 때문에  
> 이 결과를 사용하기 위해서는 **콜백(callback)** 안에서 처리해야 한다.
>
> 그런데 '그 결과를 이용해서 다시 또 다른 비동기 작업을 하고 싶다'면,  
> 그 두 번째 작업도 **첫 번째 콜백 안에서 호출** 해야 한다.
>
> 이것이 반복되면 콜백 안에 콜백이 계속 들어가면서 **중첩 구조(=콜백 헬)** 가 생기는 것이다.
>
> 결국 이런 콜백 헬은 코드의 복잡성을 높이고, 가독성을 저하시킨다.

---

### 2. 에러 처리의 한계

비동기 처리를 위한 콜백 패턴의 가장 큰 문제점은 에러 처리가 곤란하다는 것이다.

#### 동기 코드에서의 try–catch

```js
try {
  throw new Error("동기 에러");
} catch (e) {
  console.log("캐치한 에러:", e.message);
}
```

- `throw`가 실행되면 → 콜 스택의 **현재 실행 컨텍스트**에서 상위 실행 컨텍스트로 에러가 **호출자 방향으로 전파**됨
- `try–catch` 블록이 있으면 바로 거기서 잡힘

#### 비동기 콜백에서의 try–catch

```js
try {
  setTimeout(() => {
    throw new Error("비동기 에러");
  }, 0);
} catch (e) {
  console.log("캐치한 에러:", e.message);
}
```

1. `setTimeout` 호출 → 콜백 등록 → `try` 블록 **종료**
2. 전역 코드 실행 끝 → 이벤트 루프가 태스크 큐에서 콜백을 꺼냄
3. 콜백 실행 도중 `throw new Error` 발생 → **이 에러는 콜 스택을 거슬러 올라가지만, 이미 `try–catch` 블록은 사라진 상태**
4. 따라서 `catch` 블록에서는 잡을 수 없음 → 전역 에러 핸들러로 전달됨 (`window.onerror` 같은 곳)

### 3. 정리

- **비동기 처리를 위한 `콜백 패턴`**
  > 비동기 처리를 수행하는 비동기 함수는 전통적으로 **콜백 패턴**을 사용한다.
  - 콜백 헬을 발생 시켜 가독성 X
  - 에러 예외처리 어려움
  - 여러 개의 비동기 처리를 한 번에 처리하는 데도 한계가 있음

## 2) 프로미스의 생성

비동기 처리를 위한 `콜백 패턴`의 문제점을 극복하기 위해 ES6에서 **프로미스(Promise)** 가 도입되었다.

```js
const promise = new Promise((resolve, reject) => {
  // Promise 함수의 콜백 내부에서 비동기 처리를 수행한다.
  if (/* 비동기 처리 성공 */) {
    resolve('result')
  } else {
    /* 비동기 처리 실패 */
    reject ('failed reason')
  }
})
```

프로미스의 상태는 resolve 또는 reject 함수를 호출하는 것으로 결정된다.

- `fulfilled` : 비동기 처리 **성공** (resolve 함수` 호출)
- `rejected` : 비동기 처리 **실패** (reject 함수 호출)

즉, **프로미스는 비동기 처리의 상태와 결과를 관리하는 객체**다.

## 3) 프로미스의 후속 처리 메서드

프로미스 객체는 **비동기 처리 상태(fulfilled / rejected)가 바뀌었을 때** 후속 처리 메서드에 전달한 콜백을 호출한다.

- 프로미스의 후속 처리 메서드
  - `then`
  - `catch`
  - `finally`

프로미스의 **비동기 처리 상태가 변화하면** `후속 처리 메서드`에 인수로 전달한 **콜백함수가 선택적으로 호출**된다.

- **then**

  ```js
  new Promise((resolve, reject) => resolve("OK")).then(
    (v) => console.log("성공:", v), // fulfilled → 실행
    (e) => console.log("실패:", e) // rejected → 실행
  );
  ```

  - **성공/실패 후속 처리**
  - 성공(`fulfilled`) → `onFulfilled` 실행
  - 실패(`rejected`) → `onRejected` 실행
  - 항상 새 프로미스 반환

  ***

- **catch**

  ```js
  new Promise((resolve, reject) => reject("에러")).catch((e) =>
    console.log("실패:", e)
  ); // rejected → 실행
  ```

  - **실패만(`rejected`) 처리**
  - `then(undefined, onRejected)`와 동일
  - 항상 새 프로미스 반환

  ***

- **finally**

  ```js
  new Promise((resolve) => resolve("OK")).finally(() =>
    console.log("항상 실행")
  ); // 상태와 무관하게 실행
  ```

  - **성공/실패와 관계없이 무조건 실행**
  - 반환값은 무시, 이전 상태·결과를 그대로 전달
  - 주로 공통 정리 작업에 사용

<br />

```js
const promiseGet = (url) => {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.send();

    xhr.onload = () => {
      if (xhr.status === 200) {
        // 성공적으로 응답 받으면 resolve 함수 호출
        resolve(JSON.parse(xhr.response));
      } else {
        // 에러 처리를 위해 reject 함수 호출
        reject(new Error(xhr.status));
      }
    };

    xhr.onerror = () => reject(new Error("네트워크 에러"));
  });
};
// promiseGet는 프로미스 객체 반환
promiseGet("https://tistory.com/posts/1")
  .then((res) => console.log(res))
  .catch((err) => console.error(err))
  .finally(() => console.log("Bye!"));
```

## 4) 프로미스의 에러 처리

프로미스의 에러 처리는 2가지 방식이 있다

- `then(onFulfilled, onRejected)` → 두 번째 인자로 에러 처리
- `catch(onRejected)` → 별도의 에러 처리 메서드

하지만 **`catch` 메서드 활용을 더 권장한다.**

- **가독성**: 성공 로직과 에러 로직이 분리돼서 더 명확함
- **범위**: `catch`는 체인 전체를 내려오면서 발생한 에러를 한 번에 잡을 수 있음
- **일관성**: 동기 에러(`throw`)와 비동기 에러(`reject`)를 모두 동일하게 처리함

---

#### 1. `then` 두 번째 인자

```js
new Promise((_, reject) => reject("에러")).then(
  (res) => console.log("성공:", res),
  (err) => console.log("실패:", err) // 여기서만 처리됨
);
```

#### 2. `catch` 사용

```js
new Promise((_, reject) => reject("에러"))
  .then((res) => console.log("성공:", res))
  .catch((err) => console.log("실패:", err)); // 더 명확
```

#### 3. 체인 중간 에러까지 처리

```js
new Promise((resolve) => resolve(1))
  .then((num) => {
    throw new Error("중간에서 에러!");
  })
  .catch((err) => console.error("잡힘:", err.message)); // 잡힘: 중간에서 에러!
```

- `then` 두 번째 인자도 에러 처리 가능하지만, **`catch`는 체인 전체에서 발생한 에러를 잡을 수 있어 더 권장된다.**.
- 그래서 실무에서는 `then → then → ... → catch` 패턴을 기본으로 쓴다.

<br />

## 5) 프로미스 체이닝 (Promise Chaining)

프로미스의 후속 처리 메서드 `then`, `catch`, `finally`는 **항상 새로운 프로미스 객체를 반환**한다.  
따라서 메서드를 계속 이어 붙이면, 이전 단계의 결과를 다음 단계로 전달할 수 있다.

```js
getUser(1) // 사용자 조회
  .then((user) => getPosts(user.id)) // 게시글 조회
  .then((posts) => getComments(posts[0].id)) // 댓글 조회
  .then((comments) => console.log(comments))
  .catch((err) => console.error("에러 발생:", err));
```

**프로미스 체이닝을 사용하면 더 이상 `콜백 헬`이 발생하지 않는다.**  
다만 프로미스 역시 내부적으로는 콜백 함수를 사용하므로, 콜백 자체가 사라지는 것은 아니다.

콜백 패턴은 여전히 가독성이 떨어질 수 있는데, 이를 더 깔끔하게 표현하는 방법이 바로 `async / await`이다.  
`async / await`을 사용하면 후속 처리 메서드를 나열하지 않고도, **동기 코드처럼** 프로미스의 결과를 처리할 수 있다.

#### async / await 버전

```js
async function showUserComments() {
  try {
    const user = await getUser(1); // 사용자 조회
    const posts = await getPosts(user.id); // 게시글 조회
    const comments = await getComments(posts[0].id); // 댓글 조회

    console.log(comments);
  } catch (err) {
    console.error("에러 발생:", err);
  }
}

showUserComments();
```

프로미스 체이닝으로 콜백 헬을 피할 수 있지만, **궁극적으로는 `async/await`이 가장 가독성이 좋은 패턴이다.**

## 6) 프로미스 정적 메서드

| 메서드                         | 처리 순서 보장           | 병렬 처리      | 동작 요약                                                  | 간단 예시                                |
| ------------------------------ | ------------------------ | -------------- | ---------------------------------------------------------- | ---------------------------------------- |
| **Promise.resolve(v)**         | -                        | -              | 값을 즉시 성공 프로미스로 감쌈                             | `Promise.resolve(42)` → `42`             |
| **Promise.reject(e)**          | -                        | -              | 이유와 함께 즉시 실패 프로미스로 감쌈                      | `Promise.reject("에러")`                 |
| **Promise.all(\[...])**        | ✅ 입력 배열 순서 유지   | ✅ 동시에 실행 | 전부 성공해야 결과 배열 반환, 하나라도 실패 시 즉시 reject | `Promise.all([p1, p2])` → `[res1, res2]` |
| **Promise.allSettled(\[...])** | ✅ 입력 배열 순서 유지   | ✅ 동시에 실행 | 전부 완료(성공/실패 상관 없음) 후 상태·값 배열 반환        | `Promise.allSettled([p1, p2])`           |
| **Promise.race(\[...])**       | ❌ (가장 먼저 끝난 것)   | ✅ 동시에 실행 | 가장 먼저 settle(성공/실패)된 프로미스 결과 반환           | `Promise.race([p1, p2])`                 |
| **Promise.any(\[...])**        | ❌ (가장 먼저 성공한 것) | ✅ 동시에 실행 | 가장 먼저 성공한 결과 반환, 모두 실패 시 `AggregateError`  | `Promise.any([p1, p2])`                  |

## 7) 마이크로태스크 큐 (Microtask Queue / Job Queue)

```js
setTimeout(() => console.log(1), 0);

Promise.resolve()
  .then(() => console.log(2))
  .then(() => console.log(3));
```

프로미스의 후속 처리 메서드도 비동기로 동작하므로 `1 → 2 → 3` 의 순서일 것 같지만, 실제로는 `2 → 3 → 1` 순으로 출력된다.

프로미스의 후속 처리 메서드는 `태스크 큐`가 아닌 **`마이크로 태스크 큐`** 에 저장되기 때문이다.

➡️ **콜 스택이 비면, 이벤트 루프는 `마이크로태스크 큐`에서 대기하고 있는 함수를 먼저 가져와 실행한다.**  
 다시 말해 이벤트 루프는 항상 마이크로태스크 큐를 먼저 비우고, 그 다음에 태스크 큐를 확인한다.

- **태스크 큐(Task Queue)**

  - `setTimeout`, `setInterval`, DOM 이벤트 핸들러, Ajax 응답 콜백 등이 일시 저장되는 곳

- **마이크로태스크 큐(Microtask Queue / Job Queue)**
  - `Promise.then`, `catch`, `finally` 같은 프로미스의 후속 처리 메서드의 콜백함수가 일시 저장되는 곳
  - **태스크 큐보다 우선순위가 높음**

---

- `setTimeout` 콜백 → 태스크 큐
- `Promise.then` 콜백 → 마이크로태스크 큐
- **마이크로태스크 큐가 더 높은 우선순위를 가지기 때문에 `2 → 3 → 1` 순으로 실행된다.**

<br />

## 8) fetch

- `fetch` 함수는 **HTTP 요청을 보내는 클라이언트 사이드 Web API**
- **Promise 기반**으로 동작하므로 콜백 패턴의 단점을 피할 수 있음
- 반환값은 **HTTP 응답(Response 객체)을 감싼 Promise**

---

#### 1. 에러 처리 주의점

- `fetch`가 반환하는 프로미스는 **네트워크 장애나 CORS 에러** 에서만 `reject` 됨
- HTTP 상태 코드(ex. 404, 500)는 `reject`가 아니라 `resolve`로 처리됨

  → 따라서 반드시 `response.ok` 속성을 확인하여 **명시적으로 에러 처리**를 해야 함

```js
fetch("https://example.com/data")
  .then((response) => {
    if (!response.ok) throw new Error(`HTTP 에러! 상태: ${response.status}`);
    return response.json();
  })
  .then((data) => console.log(data))
  .catch((err) => console.error("실패:", err));
```

---

#### 2. axios와의 차이

- **fetch**:

  - 네트워크 장애·CORS 위반만 `reject`
  - HTTP 에러(404, 500 등)는 직접 체크해야 함 (`response.ok`)

- **axios**:

  - 네트워크 에러 + HTTP 에러 모두 `reject` 처리
  - 추가적으로 **요청/응답 인터셉터, 자동 JSON 변환, 타임아웃 설정** 등 다양한 기능 지원

---

- `fetch` = 브라우저 내장 Promise 기반 HTTP 요청 API
- 반드시 `response.ok` 확인 필요
- `axios`는 더 강력하고 편리한 기능 제공
