# 2.2 타입스크립트의 타입 시스템

## 1. 타입 애너테이션 방식

- **타입 애너테이션** : 변수나 함수에 대해 **타입을 명시적으로 선언**하여, 어떤 값이 저장될지 컴파일러에 직접 알려주는 문법.

언어마다 타입을 명시해주는 방법은 다름.

### 타입스크립트의 타입 선언 방식

- 변수 이름 뒤에 `:type` 구문을 붙임.
- 타입스크립트는 기존 자바스크립트 코드에 `점진적으로 타입을 적용`할 수 있는 특징이 있음.  
  ➡︎ 코드에서 `:type 구문`을 제거해도 정상 동작 O  
  ➡︎ 하지만 타입 제거 시 타입 추론 과정에서 어려움이 발생할 수 있음.

```typescript
let isDone: boolean = false; // boolean 타입
let decimal: number = 6; // number 타입
let color: string = "blue"; // string 타입
let list: number[] = [1, 2, 3]; // number 타입 배열
let x: [string, number]; // tuple 타입
x = ["hello", 10]; // string과 number 순서로 구성된 튜플
```

## 2. 구조적 타이핑

타입스크립트는 **구조적 타이핑(structural typing) 방식**을 채택함.  
이를 통해 `값의 구조`에 따라 타입이 결정됨.

### 1) **명목적 타입 시스템(Nominal Typing)**

     타입을 사용하는 대부분의 프로그래밍 언어에서는 `명목적 타입 시스템`을 가짐.

- **명목적 타입 시스템**은 타입의 **이름**을 기준으로 값을 구분함.
  - 값을 담고 있는 객체나 변수는 **구체적인 타입 이름**을 가짐.
  - 타입 이름이 다르면, 구조가 같더라도 서로 다른 타입으로 간주함. (**타입 이름 자체가 다르면 호환 불가**)
    - `개발자가 의도한 타입이 아닌 경우 에러가 발생`하므로, 타입의 동일성을 확인하는 데 구조적 타이핑보다 더 `안정적`임.
  - 일반적으로 상속관계나 명시적인 인터페이스를 사용해 타입 간 호환성을 명확히 정의해야함.
    - 명확한 상속관계나 공통 인터페이스가 없다면 서로 다른 클래스끼리 타입이 호환되지 않음.
  - 컴파일 타임 이후에도 남아있음.
- 명목적 타이핑 사용언어 : C++, Java

#### 예제 - 명목적 타입 시스템

```typescript
class Dog {
  sound() {
    return "Bark";
  }
}

class Cat {
  sound() {
    return "Meow";
  }
}

const animal: Dog = new Cat(); // 🚨 오류 발생 - 이름이 다른 타입 간 할당 불가능
```

### 2) 구조적 타이핑(Structural Typing)

- **구조적 타이핑**은 타입의 **구조**를 기준으로 값을 구분함.
- 즉, 타입의 이름보다는 타입이 어떤 속성을 가지고 있는지가 중요함.
  - 타입 이름과 관계없이 **속성의 구성과 타입이 같으면 같은 타입으로 간주함.** (**구조가 동일하면 이름에 관계없이 호환 가능**)
  - 이를 통해 타입 간 호환성이 유연하게 적용됨.
- 구조적 타이핑 사용언어 : TypeScript

#### 예제 1 - 구조적 타이핑

```typescript
interface Animal {
  sound(): string;
}

class Dog {
  sound() {
    return "Bark";
  }
}

class Cat {
  sound() {
    return "Meow";
  }
}

const animal: Animal = new Dog(); // ✅ 정상 동작 - 구조가 같기 때문에 호환 가능
const animal: Animal = new Cat(); // ✅ 정상 동작 - 구조가 같기 때문에 호환 가능
```

`Dog`와 `Cat` 클래스는 모두 `sound` 메서드를 가지므로, `Animal` 타입에 할당이 가능

#### 예제 2 - 구조적 타이핑

```typescript
interface Developer {
  faceValue: number;
}

interface BankNote {
  faceValue: number;
}

let developer: Developer = { faceValue: 28 };
let bankNote: BankNote = { faceValue: 1000 };

developer = bankNote; // ✅ OK
bankNote = developer; // ✅ OK
```

`Developer`와 `BankNote` 인터페이스는 모두 `faceValue`라는 속성을 가지며, 타입은 `number`로 동일한 구조를 가지고 있음.  
타입스크립트는 두 인터페이스가 이름이 달라도, **구조가 동일**하기 때문에 **호환 가능**하다고 판단함.

## 3. 구조적 서브타이핑(Structural Subtyping)

타입스크립트의 타입 시스템은 `값의 집합`으로 이해할 수 있음.  
➡︎ 타입스크립트에서는 특정 값이 `string` 또는 `number` 타입을 **동시에** 가질 수 있음.

```typescript
type stringOrNumber = string | number;
```

### 1) **구조적 서브타이핑(Structural Subtyping)**

타입스크립트의 타입 시스템에서 중요한 개념으로, 값의 **구조(속성)** 에 따라 타입 간 서브타입 관계를 결정함.

- 타입 A가 타입 B의 서브타입이 되려면, A는 B가 요구하는 모든 속성을 포함해야 함.
- 타입스크립트에서는 더 많은 속성을 가진 타입이 더 적은 속성을 가진 타입에 할당 가능.

#### 예제 - 구조적 서브타이핑

```typescript
interface Pet {
  name: string;
}

interface Cat {
  name: string;
  age: number;
}

let pet: Pet;
let cat: Cat = { name: "Kitty", age: 2 };

pet = cat; // ✅ OK
```

- `Pet`은 `name: string` 속성만 필요로 함.
- `Cat`은 `name: string`과 `age: number` 속성을 가지지만, **`name` 속성을 포함하므로** `Pet` 타입으로 호환 가능.  
  ➡︎ 더 많은 속성을 가진 타입(`Cat`)은 더 적은 속성을 요구하는 타입(`Pet`)에 할당될 수 있다!

---

#### 📌 타입스크립트의 타입 시스템과 실체 객체

타입스크립트는 **컴파일 타임**에만 타입을 확인하며, 실제 실행 시에는 **타입 정보가 제거**됩니다.  
즉, 타입스크립트에서 `pet` 변수에 `cat` 객체를 할당해도, 실제 객체(`cat`)는 여전히 원래의 속성을 유지합니다.

```typescript
console.log(pet); // { name: "Kitty", age: 2 } -> `cat` 객체가 그대로 출력됨
```

- `pet` 변수는 `Pet` 타입으로 선언되었지만, 타입스크립트는 객체의 구조적 서브타이핑을 통해 **타입 호환성을 허용할 뿐**, 실제 객체는 **원래의 속성을 그대로** 가지고 있음.

#### 📌 속성에 접근하려고 하면 오류 발생

`pet` 변수는 `Pet` 타입으로 선언되었기 때문에, **`Pet`에 정의된 속성만 사용할 수 있음.**

```typescript
// 속성에 접근하려고 하면 오류 발생
console.log(pet.name); // "Hey" -> 정상 작동
console.log(pet.age); // 오류! 'Pet' 타입에는 'age' 속성이 없음

console.log(cat.age); // 2 -> cat은 여전히 'age' 속성을 가지고 있음
```

- 타입스크립트는 `pet` 변수를 `Pet` 타입으로 인식하므로, `Pet`에 정의되지 않은 속성(`age`)에 접근하려고 하면 오류를 발생시킴.

#### 📌 타입 단언 사용 시 `pet`에서 `age`속성에 접근 가능

```typescript
console.log((pet as Cat).age); // 2 -> 'Cat'으로 타입 단언 후 접근 가능
```

---

### 2) 구조적 서브타이핑의 함수 적용

#### 예제 - 함수 매개변수에서 서브타이핑

```typescript
interface Pet {
  name: string;
}

let cat = { name: "Kitty", age: 2 };

function hello(pet: Pet) {
  console.log("Hello, " + pet.name);
}

hello(cat); // "Hello, Kitty"
```

- 함수 `hello()`는 `Pet` 타입을 받도록 설계되었지만, `cat` 객체를 전달해도 정상적으로 동작함.
- `cat` 객체가 `Pet` 타입에서 요구하는 `name` 속성을 포함하기 때문.

### 3) 클래스와 구조적 서브타이핑

#### 예제 - 타입 상속에서 서브타이핑

```typescript
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

class Developer {
  name: string;
  age: number;
  sleepTime: number;

  constructor(name: string, age: number, sleepTime: number) {
    this.name = name;
    this.age = age;
    this.sleepTime = sleepTime;
  }
}

function greet(person: Person) {
  console.log("Hello, " + person.name);
}

const developer = new Developer("Danbi", 20, 7);
greet(developer); // "Hello, Danbi"
```

- `greet()` 함수는 `Person` 타입을 매개변수로 받음.
- `Person` 타입은 `name: string`과 `age: number` 속성을 요구함
- `Developer` 클래스는 `name: string`과 `age: number`, `sleepTime: number` 속성을 가짐.
  - `Developer` 타입은 `sleepTime` 속성을 추가로 가지지만, 타입스크립트는 필요 없는 추가 속성을 무시.
  - 런타임에서 실제 객체(`developer`)는 `sleepTime` 속성을 포함한 원래의 상태를 유지함.
  - `greet` 함수는 `person.name`에만 접근하므로, 다른 속성(`sleepTime`)은 사용되지 않음!
- `Developer`는 `Person`의 요구사항인 **`name`과 `age` 속성을 포함하고 있으므로**, **타입스크립트는 `Developer`를 `Person` 타입으로 간주할 수 있음**
- 따라서 `Developer`의 인스턴스(`developer`)를 `Person` 타입으로 사용할 수 있다.

서로 다른 두 타입간의 호환성은 오로지 타입 내부 구조에 의해 결정된다.  
타입 A가 타입 B의 서브타입이라면(=타입 A가 타입 B의 모든 속성과 타입을 포함하고 있다면), A타입의 인스턴스는 B타입이 필요한 곳에 언제든지 위치할 수 있다.

### ✅ 구조적 서브타이핑의 요점

1. **타입은 이름이 아니라 구조로 판단**된다.
   - `Person`과 `Developer`는 이름이 다르지만, 구조적으로 호환된다.
2. **더 많은 속성을 가진 타입은 더 적은 속성을 가진 타입에 할당 가능**하다.

   - `Developer`는 `Person`이 요구하는 모든 속성을 포함하므로 `Person` 타입으로 사용할 수 있다.

3. **런타임 객체는 변하지 않는다.**
   - 타입스크립트의 타입 체크는 컴파일 타임에만 작동하므로, 런타임 객체(`developer`)는 여전히 모든 속성을 유지한다.

---

## 4. 자바스크립트를 닮은 타입스크립트

타입스크립트가 `구조적 타이핑`을 채택한 이유는 타입스크립트가 자바스크립트를 모델링한 언어이기 때문이다.

- 자바스크립트는 `덕 타이핑(duck typing)`을 기반으로 동작함
  - **덕 타이핑** : 함수의 매개변수 값이 요구하는 속성을 갖추고 있다면, 그 값이 어떤 방식으로 생성되었는지는 중요하지 않음.  
    _ex. 만약 어떤 새가 오리처럼 걷고 `꽥꽥`거리고 `헤엄`친다면, 우리는 그 새를 `오리`라고 부를 것이다. 🦆_

`쉬운 사용성`과 `안전성`을 중시하는 타입스크립트는 객체 간 속성이 동일하다면 서로 호환되는 **구조적 타입 시스템**을 제공하여 유연한 타이핑과 편리성을 높임.

### 1) 덕 타이핑 vs 구조적 타이핑

자바스크립트의 덕 타이핑과 타입스크립트의 구조적 타이핑은 객체의 속성을 기반으로 타입을 검사한다는 공통점이 있지만, **타입 검사 시점**에서 차이가 있다.

|                 | **덕 타이핑** | **구조적 타이핑** |
| --------------- | ------------- | ----------------- |
| **사용 언어**   | 자바스크립트  | 타입스크립트      |
| **검사 시점**   | 런타임        | 컴파일 타임       |
| **타이핑 방식** | 동적 타이핑   | 정적 타이핑       |

## 5. 구조적 타이핑의 결과

구조적 타이핑의 특징 때문에 **예기치 못한 결과**가 나올 때가 있다.

#### 예제 1 - 예상과 다른 타입 에러

```typescript
interface Cube {
  width: number;
  height: number;
  depth: number;
}

function addLines(c: Cube) {
  let total = 0;

  for (const axis of Ojbect.keys(c)) {
    // 🚨 오류: 'c[axis]'의 타입을 'number'로 확정할 수 없음
    const length = c[axis];

    total += length; // Element implicitly has an 'any' type 오류
  }
}
```

- `addLines()` 함수의 매개변수 ``c`가 `Cube` 타입으로 선언됨.
- `Cube` 인터페이스는 `width`, `height`, `depth` 속성을 모두 `number` 타입으로 정의함.
- 그래서 당연히 `c[axis]`는 `number` 타입일 것이라 예측함.
- 🚨 **하지만 `구조적 타이핑의 특성`으로 인해 `c`는 `Cube`의 외에도 추가로 어떤 속성이든 가질 수 있음**
  - 타입스크립트는 `c[axis]`가 항상 `number`일 것이라고 확신할 수 없음
  - `c[axis]`의 타입이 string일 수도 있어 에러 발생

#### 예제 2 - 추가 속성이 포함된 객체

```typescript
const sampleCube = {
  width:6,
  height:5,
  depth:4,
  name:"sweetCube", // string 타입의 추가 속성
}

addLines(sampleCube); // ✅ OK - 구조적 타이핑으로 문제 없음
```

- `sampleCube`는 `Cube` 타입의 구조를 포함하면서도 `name` 같은 추가 속성을 가질 수 있음.
- 타입스크립트는 런타임에 `name` 같은 속성이 들어오지 않을 것을 보장할 수 없으므로, **`c[axis]`의 타입을 `any`로 추론함.**
- **결과적으로, `c[axis]`의 타입을 `number`로 확정할 수 없어서 오류가 발생합니다.**

이러한 한계 때문에 타입스크립트에 명목적 타이핑 언어의 특징을 가미한 `유니온` 같은 방법이 생겨남.


## 6. 타입스크립트의 점진적 타입 확인
타입스크립트는 점진적으로 타입을 확인하는 언어다.

### 1) 점진적 타입 검사
- **점진적 타입 검사** : 컴파일 타임에 타입을 검사하면서 필요에 따라 타입 선언 생략을 허용하는 방식.
  - 타입을 지정한 경우: `정적`으로 타입을 검사.
  - 타입을 생략한 경우: `동적`으로 타입을 검사(`any`로 추론). 

#### 예제 - 타입 선언 생략 시의 `암시적 타입 변환`
```typescript
function(x,y){
  return x+y
}
//위 코드는 아래와 같이 암시적 타입 변환이 일어난다.
function(x:any, y:any):any
```
x, y에 타입을 선언하지 않았으나 타입스크립트 컴파일러는 x, y가 잘못된 것이라 여기지 않는다. 다만, 타입을 명시하지 않았기에 `any` 타입으로 추론한다.

### 2) 타입스크립트의 유연성

타입스크립트는 필요에 따라 타입을 생략할 수도, 타입을 점진적으로 추가할 수도 있다. 즉 **컴파일하는 데 모든 타입을 반드시 알아야 하는 것은 아니다**. 그저 모든 타입을 알고 있을 때 최상의 결과를 보여준다.

타입스크립트는 자바스크립트의 슈퍼셋 언어이기 때문에 `.ts` 파일에 자바스크립트 문법으로 코드를 작성하여도 문제가 발생하지 않는다. 타입이 없는 자바스크립트 코드를 타입스크립트로 마이그레이션할 때, 타입스크립트의 점진적 타이핑이라는 특징을 유용하게 활용할 수 있다. 
#### 예제 - 자바스크립트 코드를 타입스크립트로 마이그레이션
```javascript
// 기존 자바스크립트 코드
const greet = (name) => console.log(`Hello, ${name}!`);
```

```typescript
// 타입스크립트로 변환 (점진적 타입 추가)
const greet = (name: string): void => console.log(`Hello, ${name}!`);
```